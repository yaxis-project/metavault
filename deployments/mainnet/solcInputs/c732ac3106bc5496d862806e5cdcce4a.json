{
  "language": "Solidity",
  "sources": {
    "contracts/governance/interfaces/IMasterChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IMasterChef {\n    function userInfo(uint256, address) external view returns (uint256, uint256, uint256);\n    function pendingYaxis(uint256, address) external view returns (uint256);\n}\n"
    },
    "contracts/governance/YaxisVotePower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IMasterChef.sol\";\nimport \"./interfaces/IUniswapV2Pair.sol\";\nimport \"./interfaces/IVoteProxy.sol\";\nimport \"./interfaces/IYaxisBar.sol\";\n\ncontract YaxisVotePower is IVoteProxy {\n    using SafeMath for uint256;\n\n    uint256 public constant PID = 6;\n    // solhint-disable-next-line const-name-snakecase\n    uint8 public constant override decimals = uint8(18);\n\n    // ETH/YAX token\n    IUniswapV2Pair public immutable yaxEthUniswapV2Pair;\n\n    // YAX token\n    IERC20 public immutable yax;\n\n    // YaxisChef contract\n    IMasterChef public immutable chef;\n\n    // sYAX token\n    IYaxisBar public immutable yaxisBar;\n\n    constructor(\n        address _yax,\n        address _yaxisChef,\n        address _yaxisBar,\n        address _yaxEthUniswapV2Pair\n    )\n        public\n    {\n        yax = IERC20(_yax);\n        chef = IMasterChef(_yaxisChef);\n        yaxisBar = IYaxisBar(_yaxisBar);\n        yaxEthUniswapV2Pair = IUniswapV2Pair(_yaxEthUniswapV2Pair);\n    }\n\n    function totalSupply()\n        external\n        view\n        override\n        returns (uint256 _supply)\n    {\n        (uint256 _yaxReserves,,) = yaxEthUniswapV2Pair.getReserves();\n        _supply = yaxEthUniswapV2Pair.totalSupply();\n        _supply = _supply == 0\n            ? 1e18\n            : _supply;\n        uint256 _lpStakingYax = _yaxReserves\n            .mul(yaxEthUniswapV2Pair.balanceOf(address(chef)))\n            .div(_supply);\n        _supply = sqrt(\n            yax.totalSupply()\n                .add(_lpStakingYax)\n                .add(yaxisBar.availableBalance())\n        );\n    }\n\n    function balanceOf(\n        address _voter\n    )\n        external\n        view\n        override\n        returns (uint256 _balance)\n    {\n        (uint256 _stakeAmount,,) = chef.userInfo(PID, _voter);\n        (uint256 _yaxReserves,,) = yaxEthUniswapV2Pair.getReserves();\n        uint256 _supply = yaxEthUniswapV2Pair.totalSupply();\n        _supply = _supply == 0\n            ? 1e18\n            : _supply;\n        uint256 _lpStakingYax = _yaxReserves\n            .mul(_stakeAmount)\n            .div(_supply)\n            .add(chef.pendingYaxis(PID, _voter));\n        _supply = yaxisBar.totalSupply();\n        _supply = _supply == 0\n            ? 1e18\n            : _supply;\n        uint256 _syaxAmount = yaxisBar.balanceOf(_voter)\n            .mul(yaxisBar.availableBalance())\n            .div(_supply);\n        _balance = sqrt(\n            yax.balanceOf(_voter)\n                .add(_lpStakingYax)\n                .add(_syaxAmount)\n        );\n    }\n\n    function sqrt(\n        uint256 x\n    )\n        private\n        pure\n        returns (uint256 y)\n    {\n        uint256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n        y = y * (10 ** 9);\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/governance/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IUniswapV2Pair is IERC20 {\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n}\n"
    },
    "contracts/governance/interfaces/IVoteProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IVoteProxy {\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address _voter) external view returns (uint256);\n}\n"
    },
    "contracts/governance/interfaces/IYaxisBar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IYaxisBar is IERC20 {\n    function availableBalance() external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/metavault/yAxisMetaVaultManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./IVaultManager.sol\";\n\n/**\n * @title yAxisMetaVaultManager\n * @notice This contract serves as the central point for governance-voted\n * variables. Fees and permissioned addresses are stored and referenced in\n * this contract only.\n */\ncontract yAxisMetaVaultManager is IVaultManager { // solhint-disable-line contract-name-camelcase\n    using SafeERC20 for IERC20;\n\n    address public override governance;\n    address public override harvester;\n    address public override insurancePool;\n    address public override stakingPool;\n    address public override strategist;\n    address public override treasury;\n    address public override yax;\n\n    /**\n     *  The following fees are all mutable.\n     *  They are updated by governance (community vote).\n     */\n    uint256 public override insuranceFee;\n    uint256 public override insurancePoolFee;\n    uint256 public override stakingPoolShareFee;\n    uint256 public override treasuryBalance;\n    uint256 public override treasuryFee;\n    uint256 public override withdrawalProtectionFee;\n\n    mapping(address => bool) public override vaults;\n    mapping(address => bool) public override controllers;\n\n    /**\n     * @param _yax The address of the YAX token\n     */\n    constructor(address _yax) public {\n        yax = _yax;\n        governance = msg.sender;\n        strategist = msg.sender;\n        harvester = msg.sender;\n        stakingPoolShareFee = 2000;\n        treasuryBalance = 20000e18;\n        treasuryFee = 500;\n        withdrawalProtectionFee = 10;\n    }\n\n    /**\n     * GOVERNANCE-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Allows governance to pull tokens out of this contract\n     * (it should never hold tokens)\n     * @param _token The address of the token\n     * @param _amount The amount to withdraw\n     * @param _to The address to send to\n     */\n    function governanceRecoverUnsupported(\n        IERC20 _token,\n        uint256 _amount,\n        address _to\n    ) external {\n        require(msg.sender == governance, \"!governance\");\n        _token.safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @notice Sets the governance address\n     * @param _governance The address of the governance\n     */\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n    /**\n     * @notice Sets the insurance fee\n     * @dev Throws if setting fee over 1%\n     * @param _insuranceFee The value for the insurance fee\n     */\n    function setInsuranceFee(uint256 _insuranceFee) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_insuranceFee <= 100, \"_insuranceFee over 1%\");\n        insuranceFee = _insuranceFee;\n    }\n\n    /**\n     * @notice Sets the insurance pool address\n     * @param _insurancePool The address of the insurance pool\n     */\n    function setInsurancePool(address _insurancePool) public {\n        require(msg.sender == governance, \"!governance\");\n        insurancePool = _insurancePool;\n    }\n\n    /**\n     * @notice Sets the insurance pool fee\n     * @dev Throws if setting fee over 20%\n     * @param _insurancePoolFee The value for the insurance pool fee\n     */\n    function setInsurancePoolFee(uint256 _insurancePoolFee) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_insurancePoolFee <= 2000, \"_insurancePoolFee over 20%\");\n        insurancePoolFee = _insurancePoolFee;\n    }\n\n    /**\n     * @notice Sets the staking pool address\n     * @param _stakingPool The address of the staking pool\n     */\n    function setStakingPool(address _stakingPool) public {\n        require(msg.sender == governance, \"!governance\");\n        stakingPool = _stakingPool;\n    }\n\n    /**\n     * @notice Sets the staking pool share fee\n     * @dev Throws if setting fee over 50%\n     * @param _stakingPoolShareFee The value for the staking pool fee\n     */\n    function setStakingPoolShareFee(uint256 _stakingPoolShareFee) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_stakingPoolShareFee <= 5000, \"_stakingPoolShareFee over 50%\");\n        stakingPoolShareFee = _stakingPoolShareFee;\n    }\n\n    /**\n     * @notice Sets the strategist address\n     * @param _strategist The address of the strategist\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == governance, \"!governance\");\n        strategist = _strategist;\n    }\n\n    /**\n     * @notice Sets the treasury address\n     * @param _treasury The address of the treasury\n     */\n    function setTreasury(address _treasury) public {\n        require(msg.sender == governance, \"!governance\");\n        treasury = _treasury;\n    }\n\n    /**\n     * @notice Sets the maximum treasury balance\n     * @dev Strategies will read this value to determine whether or not\n     * to give the treasury the treasuryFee\n     * @param _treasuryBalance The maximum balance of the treasury\n     */\n    function setTreasuryBalance(uint256 _treasuryBalance) public {\n        require(msg.sender == governance, \"!governance\");\n        treasuryBalance = _treasuryBalance;\n    }\n\n    /**\n     * @notice Sets the treasury fee\n     * @dev Throws if setting fee over 20%\n     * @param _treasuryFee The value for the treasury fee\n     */\n    function setTreasuryFee(uint256 _treasuryFee) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_treasuryFee <= 2000, \"_treasuryFee over 20%\");\n        treasuryFee = _treasuryFee;\n    }\n\n    /**\n     * @notice Sets the withdrawal protection fee\n     * @dev Throws if setting fee over 1%\n     * @param _withdrawalProtectionFee The value for the withdrawal protection fee\n     */\n    function setWithdrawalProtectionFee(uint256 _withdrawalProtectionFee) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_withdrawalProtectionFee <= 100, \"_withdrawalProtectionFee over 1%\");\n        withdrawalProtectionFee = _withdrawalProtectionFee;\n    }\n\n    /**\n     * @notice Sets the YAX address\n     * @param _yax The address of the YAX token\n     */\n    function setYax(address _yax) external {\n        require(msg.sender == governance, \"!governance\");\n        yax = _yax;\n    }\n\n    /**\n     * (GOVERNANCE|STRATEGIST)-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Sets the status for a controller\n     * @param _controller The address of the controller\n     * @param _status The status of the controller\n     */\n    function setControllerStatus(address _controller, bool _status) external {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        controllers[_controller] = _status;\n    }\n\n    /**\n     * @notice Sets the harvester address\n     * @param _harvester The address of the harvester\n     */\n    function setHarvester(address _harvester) external {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        harvester = _harvester;\n    }\n\n    /**\n     * @notice Sets the status for a vault\n     * @param _vault The address of the vault\n     * @param _status The status of the vault\n     */\n    function setVaultStatus(address _vault, bool _status) external {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        vaults[_vault] = _status;\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns a tuple of:\n     *     YAX token,\n     *     Staking pool address,\n     *     Staking pool share fee,\n     *     Treasury address,\n     *     Checks the balance of the treasury and returns the treasury fee\n     *         if below the treasuryBalance, or 0 if above\n     */\n    function getHarvestFeeInfo()\n        external\n        view\n        override\n        returns (address, address, uint256, address, uint256, address, uint256)\n    {\n        return (\n            yax,\n            stakingPool,\n            stakingPoolShareFee,\n            treasury,\n            IERC20(yax).balanceOf(treasury) >= treasuryBalance ? 0 : treasuryFee,\n            insurancePool,\n            insurancePoolFee\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/metavault/IVaultManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IVaultManager {\n    function controllers(address) external view returns (bool);\n    function getHarvestFeeInfo() external view returns (address, address, uint256, address, uint256, address, uint256);\n    function governance() external view returns (address);\n    function harvester() external view returns (address);\n    function insuranceFee() external view returns (uint256);\n    function insurancePool() external view returns (address);\n    function insurancePoolFee() external view returns (uint256);\n    function stakingPool() external view returns (address);\n    function stakingPoolShareFee() external view returns (uint256);\n    function strategist() external view returns (address);\n    function treasury() external view returns (address);\n    function treasuryBalance() external view returns (uint256);\n    function treasuryFee() external view returns (uint256);\n    function vaults(address) external view returns (bool);\n    function withdrawalProtectionFee() external view returns (uint256);\n    function yax() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/metavault/yAxisMetaVaultHarvester.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./IController.sol\";\nimport \"./IHarvester.sol\";\nimport \"./IVaultManager.sol\";\n\n/**\n * @title yAxisMetaVaultHarvester\n * @notice This contract is to be used as a central point to call\n * harvest on all strategies for any given token. It has its own\n * permissions for harvesters (set by the strategist or governance).\n */\ncontract yAxisMetaVaultHarvester is IHarvester { // solhint-disable-line contract-name-camelcase\n    using SafeMath for uint256;\n\n    IVaultManager public vaultManager;\n    IController public controller;\n\n    struct Strategy {\n        uint256 timeout;\n        uint256 lastCalled;\n        address[] addresses;\n    }\n\n    mapping(address => Strategy) public strategies;\n    mapping(address => bool) public isHarvester;\n\n    /**\n     * @notice Logged when a controller is set\n     */\n    event ControllerSet(address indexed controller);\n\n    /**\n     * @notice Logged when harvest is called for a strategy\n     */\n    event Harvest(\n        address indexed controller,\n        address indexed strategy\n    );\n\n    /**\n     * @notice Logged when a harvester is set\n     */\n    event HarvesterSet(address indexed harvester, bool status);\n\n    /**\n     * @notice Logged when a strategy is added for a token\n     */\n    event StrategyAdded(address indexed token, address indexed strategy, uint256 timeout);\n\n    /**\n     * @notice Logged when a strategy is removed for a token\n     */\n    event StrategyRemoved(address indexed token, address indexed strategy, uint256 timeout);\n\n    /**\n     * @notice Logged when a vault manger is set\n     */\n    event VaultManagerSet(address indexed vaultManager);\n\n    /**\n     * @param _vaultManager The address of the yAxisMetaVaultManager contract\n     * @param _controller The address of the controller\n     */\n    constructor(address _vaultManager, address _controller) public {\n        vaultManager = IVaultManager(_vaultManager);\n        controller = IController(_controller);\n    }\n\n    /**\n     * (GOVERNANCE|STRATEGIST)-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Adds a strategy to the rotation for a given token and sets a timeout\n     * @param _token The address of the token\n     * @param _strategy The address of the strategy\n     * @param _timeout The timeout between harvests\n     */\n    function addStrategy(\n        address _token,\n        address _strategy,\n        uint256 _timeout\n    ) external override onlyStrategist {\n        strategies[_token].addresses.push(_strategy);\n        strategies[_token].timeout = _timeout;\n        emit StrategyAdded(_token, _strategy, _timeout);\n    }\n\n    /**\n     * @notice Removes a strategy from the rotation for a given token and sets a timeout\n     * @param _token The address of the token\n     * @param _strategy The address of the strategy\n     * @param _timeout The timeout between harvests\n     */\n    function removeStrategy(\n        address _token,\n        address _strategy,\n        uint256 _timeout\n    ) external override onlyStrategist {\n        uint256 tail = strategies[_token].addresses.length;\n        uint256 index;\n        bool found;\n        for (uint i; i < tail; i++) {\n            if (strategies[_token].addresses[i] == _strategy) {\n                index = i;\n                found = true;\n                break;\n            }\n        }\n\n        if (found) {\n            strategies[_token].addresses[index] = strategies[_token].addresses[tail.sub(1)];\n            strategies[_token].addresses.pop();\n            strategies[_token].timeout = _timeout;\n            emit StrategyRemoved(_token, _strategy, _timeout);\n        }\n    }\n\n    /**\n     * @notice Sets the address of the controller\n     * @param _controller The address of the controller\n     */\n    function setController(IController _controller) external onlyStrategist {\n        controller = _controller;\n        emit ControllerSet(address(_controller));\n    }\n\n    /**\n     * @notice Sets the status of a harvester address to be able to call harvest functions\n     * @param _harvester The address of the harvester\n     * @param _status The status to allow the harvester to harvest\n     */\n    function setHarvester(address _harvester, bool _status) public onlyStrategist {\n        isHarvester[_harvester] = _status;\n        emit HarvesterSet(_harvester, _status);\n    }\n\n    /**\n     * @notice Sets the address of the vault manager contract\n     * @param _vaultManager The address of the vault manager\n     */\n    function setVaultManager(address _vaultManager) external onlyStrategist {\n        vaultManager = IVaultManager(_vaultManager);\n        emit VaultManagerSet(_vaultManager);\n    }\n\n    /**\n     * (GOVERNANCE|STRATEGIST|HARVESTER)-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Harvests a given strategy on the provided controller\n     * @dev This function ignores the timeout\n     * @param _controller The address of the controller\n     * @param _strategy The address of the strategy\n     */\n    function harvest(\n        IController _controller,\n        address _strategy\n    ) public onlyHarvester {\n        _controller.harvestStrategy(_strategy);\n        emit Harvest(address(_controller), _strategy);\n    }\n\n    /**\n     * @notice Harvests the next available strategy for a given token and\n     * rotates the strategies\n     * @param _token The address of the token\n     */\n    function harvestNextStrategy(address _token) external {\n        require(canHarvest(_token), \"!canHarvest\");\n        address strategy = strategies[_token].addresses[0];\n        harvest(controller, strategy);\n        uint256 k = strategies[_token].addresses.length;\n        if (k > 1) {\n            address[] memory _strategies = new address[](k);\n            for (uint i; i < k-1; i++) {\n                _strategies[i] = strategies[_token].addresses[i+1];\n            }\n            _strategies[k-1] = strategy;\n            strategies[_token].addresses = _strategies;\n        }\n        // solhint-disable-next-line not-rely-on-time\n        strategies[_token].lastCalled = block.timestamp;\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the addresses of the strategies for a given token\n     * @param _token The address of the token\n     */\n    function strategyAddresses(address _token) external view returns (address[] memory) {\n        return strategies[_token].addresses;\n    }\n\n    /**\n     * PUBLIC VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the availability of a token's strategy to be harvested\n     * @param _token The address of the token\n     */\n    function canHarvest(address _token) public view returns (bool) {\n        Strategy storage strategy = strategies[_token];\n        if (strategy.addresses.length == 0 ||\n            // solhint-disable-next-line not-rely-on-time\n            strategy.lastCalled > block.timestamp.sub(strategy.timeout)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    modifier onlyHarvester() {\n        require(isHarvester[msg.sender], \"!harvester\");\n        _;\n    }\n\n    modifier onlyStrategist() {\n        require(vaultManager.controllers(msg.sender)\n             || msg.sender == vaultManager.strategist()\n             || msg.sender == vaultManager.governance(),\n             \"!strategist\"\n        );\n        _;\n    }\n}\n"
    },
    "contracts/metavault/IController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IController {\n    function balanceOf(address) external view returns (uint256);\n    function earn(address, uint256) external;\n    function investEnabled() external view returns (bool);\n    function harvestStrategy(address) external;\n    function strategyTokens(address) external returns (address);\n    function vaults(address) external view returns (address);\n    function want(address) external view returns (address);\n    function withdraw(address, uint256) external;\n    function withdrawFee(address, uint256) external view returns (uint256);\n}\n"
    },
    "contracts/metavault/IHarvester.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IHarvester {\n    function addStrategy(address, address, uint256) external;\n    function removeStrategy(address, address, uint256) external;\n}\n\n"
    },
    "contracts/metavault/controllers/StrategyControllerV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../IController.sol\";\nimport \"../IConverter.sol\";\nimport \"../IHarvester.sol\";\nimport \"../IMetaVault.sol\";\nimport \"../IStrategy.sol\";\nimport \"../IVaultManager.sol\";\n\n/**\n * @title StrategyControllerV2\n * @notice This controller allows multiple strategies to be used\n * for a single token, and multiple tokens are supported.\n */\ncontract StrategyControllerV2 is IController {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    bool public globalInvestEnabled;\n    uint256 public maxStrategies;\n    IVaultManager public vaultManager;\n\n    struct TokenStrategy {\n        address[] strategies;\n        mapping(address => uint256) index;\n        mapping(address => bool) active;\n        mapping(address => uint256) caps;\n    }\n\n    // token => (want => converter)\n    mapping(address => mapping(address => address)) public converters;\n    // token => TokenStrategy\n    mapping(address => TokenStrategy) internal tokenStrategies;\n    // strategy => token\n    mapping(address => address) public override strategyTokens;\n    // token => vault\n    mapping(address => address) public override vaults;\n    // vault => token\n    mapping(address => address) public vaultTokens;\n\n    /**\n     * @notice Logged when earn is called for a strategy\n     */\n    event Earn(address indexed strategy);\n\n    /**\n     * @notice Logged when harvest is called for a strategy\n     */\n    event Harvest(address indexed strategy);\n\n    /**\n     * @notice Logged when insurance is claimed for a vault\n     */\n    event InsuranceClaimed(address indexed vault);\n\n    /**\n     * @notice Logged when a converter is set\n     */\n    event SetConverter(address input, address output, address converter);\n\n    /**\n     * @notice Logged when a vault manager is set\n     */\n    event SetVaultManager(address vaultManager);\n\n    /**\n     * @notice Logged when a strategy is added for a token\n     */\n    event StrategyAdded(address indexed token, address indexed strategy, uint256 cap);\n\n    /**\n     * @notice Logged when a strategy is removed for a token\n     */\n    event StrategyRemoved(address indexed token, address indexed strategy);\n\n    /**\n     * @notice Logged when strategies are reordered for a token\n     */\n    event StrategiesReordered(\n        address indexed token,\n        address indexed strategy1,\n        address indexed strategy2\n    );\n\n    /**\n     * @param _vaultManager The address of the vaultManager\n     */\n    constructor(address _vaultManager) public {\n        vaultManager = IVaultManager(_vaultManager);\n        globalInvestEnabled = true;\n        maxStrategies = 10;\n    }\n\n    /**\n     * GOVERNANCE-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Adds a strategy for a given token\n     * @dev Only callable by governance\n     * @param _token The address of the token\n     * @param _strategy The address of the strategy\n     * @param _cap The cap of the strategy\n     * @param _converter The converter of the strategy (can be zero address)\n     * @param _canHarvest Flag for whether the strategy can be harvested\n     * @param _timeout The timeout between harvests\n     */\n    function addStrategy(\n        address _token,\n        address _strategy,\n        uint256 _cap,\n        address _converter,\n        bool _canHarvest,\n        uint256 _timeout\n    ) external onlyGovernance {\n        // ensure the strategy hasn't been added\n        require(!tokenStrategies[_token].active[_strategy], \"active\");\n        address _want = IStrategy(_strategy).want();\n        // ensure a converter is added if the strategy's want token is\n        // different than the want token of the vault\n        if (_want != IMetaVault(vaults[_token]).want()) {\n            require(_converter != address(0), \"!_converter\");\n            converters[_token][_want] = _converter;\n            // enable the strategy on the converter\n            IConverter(_converter).setStrategy(_strategy, true);\n        }\n        // get the index of the newly added strategy\n        uint256 index = tokenStrategies[_token].strategies.length;\n        // ensure we haven't added too many strategies already\n        require(index < maxStrategies, \"!maxStrategies\");\n        // push the strategy to the array of strategies\n        tokenStrategies[_token].strategies.push(_strategy);\n        // set the cap\n        tokenStrategies[_token].caps[_strategy] = _cap;\n        // set the index\n        tokenStrategies[_token].index[_strategy] = index;\n        // activate the strategy\n        tokenStrategies[_token].active[_strategy] = true;\n        // store the reverse mapping\n        strategyTokens[_strategy] = _token;\n        // if the strategy should be harvested\n        if (_canHarvest) {\n            // add it to the harvester\n            IHarvester(vaultManager.harvester()).addStrategy(_token, _strategy, _timeout);\n        }\n        emit StrategyAdded(_token, _strategy, _cap);\n    }\n\n    /**\n     * @notice Claims the insurance fund of a vault\n     * @dev Only callable by governance\n     * @dev When insurance is claimed by the controller, the insurance fund of\n     * the vault is zeroed out, increasing the getPricePerFullShare and applying\n     * the gains to everyone in the vault.\n     * @param _vault The address of the vault\n     */\n    function claimInsurance(address _vault) external onlyGovernance {\n        IMetaVault(_vault).claimInsurance();\n        emit InsuranceClaimed(_vault);\n    }\n\n    /**\n     * @notice Sets the address of the vault manager contract\n     * @dev Only callable by governance\n     * @param _vaultManager The address of the vault manager\n     */\n    function setVaultManager(address _vaultManager) external onlyGovernance {\n        vaultManager = IVaultManager(_vaultManager);\n        emit SetVaultManager(_vaultManager);\n    }\n\n    /**\n     * (GOVERNANCE|STRATEGIST)-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Withdraws token from a strategy to governance\n     * @dev Only callable by governance or the strategist\n     * @param _strategy The address of the strategy\n     * @param _token The address of the token\n     */\n    function inCaseStrategyGetStuck(\n        address _strategy,\n        address _token\n    ) external onlyStrategist {\n        IStrategy(_strategy).withdraw(_token);\n        IERC20(_token).safeTransfer(\n            vaultManager.governance(),\n            IERC20(_token).balanceOf(address(this))\n        );\n    }\n\n    /**\n     * @notice Withdraws token from the controller to governance\n     * @dev Only callable by governance or the strategist\n     * @param _token The address of the token\n     * @param _amount The amount that will be withdrawn\n     */\n    function inCaseTokensGetStuck(\n        address _token,\n        uint256 _amount\n    ) external onlyStrategist {\n        IERC20(_token).safeTransfer(vaultManager.governance(), _amount);\n    }\n\n    /**\n     * @notice Removes a strategy for a given token\n     * @dev Only callable by governance or strategist\n     * @param _token The address of the token\n     * @param _strategy The address of the strategy\n     * @param _timeout The timeout between harvests\n     */\n    function removeStrategy(\n        address _token,\n        address _strategy,\n        uint256 _timeout\n    ) external onlyStrategist {\n        TokenStrategy storage tokenStrategy = tokenStrategies[_token];\n        // ensure the strategy is already added\n        require(tokenStrategy.active[_strategy], \"!active\");\n        // get the index of the strategy to remove\n        uint256 index = tokenStrategy.index[_strategy];\n        // get the index of the last strategy\n        uint256 tail = tokenStrategy.strategies.length.sub(1);\n        // get the address of the last strategy\n        address replace = tokenStrategy.strategies[tail];\n        // replace the removed strategy with the tail\n        tokenStrategy.strategies[index] = replace;\n        // set the new index for the replaced strategy\n        tokenStrategy.index[replace] = index;\n        // remove the duplicate replaced strategy\n        tokenStrategy.strategies.pop();\n        // remove the strategy's index\n        delete tokenStrategy.index[_strategy];\n        // remove the strategy's cap\n        delete tokenStrategy.caps[_strategy];\n        // deactivate the strategy\n        delete tokenStrategy.active[_strategy];\n        // pull funds from the removed strategy to the vault\n        IStrategy(_strategy).withdrawAll();\n        // remove the strategy from the harvester\n        IHarvester(vaultManager.harvester()).removeStrategy(_token, _strategy, _timeout);\n        // get the strategy want token\n        address _want = IStrategy(_strategy).want();\n        // if a converter is used\n        if (_want != IMetaVault(vaults[_token]).want()) {\n            // disable the strategy on the converter\n            IConverter(converters[_token][_want]).setStrategy(_strategy, false);\n        }\n        emit StrategyRemoved(_token, _strategy);\n    }\n\n    /**\n     * @notice Reorders two strategies for a given token\n     * @dev Only callable by governance or strategist\n     * @param _token The address of the token\n     * @param _strategy1 The address of the first strategy\n     * @param _strategy2 The address of the second strategy\n     */\n    function reorderStrategies(\n        address _token,\n        address _strategy1,\n        address _strategy2\n    ) external onlyStrategist {\n        require(_strategy1 != _strategy2, \"_strategy1 == _strategy2\");\n        TokenStrategy storage tokenStrategy = tokenStrategies[_token];\n        // ensure the strategies are already added\n        require(tokenStrategy.active[_strategy1]\n             && tokenStrategy.active[_strategy2],\n             \"!active\");\n        // get the indexes of the strategies\n        uint256 index1 = tokenStrategy.index[_strategy1];\n        uint256 index2 = tokenStrategy.index[_strategy2];\n        // set the new addresses at their indexes\n        tokenStrategy.strategies[index1] = _strategy2;\n        tokenStrategy.strategies[index2] = _strategy1;\n        // update indexes\n        tokenStrategy.index[_strategy1] = index2;\n        tokenStrategy.index[_strategy2] = index1;\n        emit StrategiesReordered(_token, _strategy1, _strategy2);\n    }\n\n    /**\n     * @notice Sets/updates the cap of a strategy for a token\n     * @dev Only callable by governance or strategist\n     * @dev If the balance of the strategy is greater than the new cap (except if\n     * the cap is 0), then withdraw the difference from the strategy to the vault.\n     * @param _token The address of the token\n     * @param _strategy The address of the strategy\n     * @param _cap The new cap of the strategy\n     */\n    function setCap(\n        address _token,\n        address _strategy,\n        uint256 _cap\n    ) external onlyStrategist {\n        require(tokenStrategies[_token].active[_strategy], \"!active\");\n        tokenStrategies[_token].caps[_strategy] = _cap;\n        uint256 _balance = IStrategy(_strategy).balanceOf();\n        // send excess funds (over cap) back to the vault\n        if (_balance > _cap && _cap != 0) {\n            uint256 _diff = _balance.sub(_cap);\n            IStrategy(_strategy).withdraw(_diff);\n        }\n    }\n\n    /**\n     * @notice Sets/updates the converter for given input and output tokens\n     * @dev Only callable by governance or strategist\n     * @param _input The address of the input token\n     * @param _output The address of the output token\n     * @param _converter The address of the converter\n     */\n    function setConverter(\n        address _input,\n        address _output,\n        address _converter\n    ) external onlyStrategist {\n        converters[_input][_output] = _converter;\n        emit SetConverter(_input, _output, _converter);\n    }\n\n    /**\n     * @notice Sets/updates the global invest enabled flag\n     * @dev Only callable by governance or strategist\n     * @param _investEnabled The new bool of the invest enabled flag\n     */\n    function setInvestEnabled(bool _investEnabled) external onlyStrategist {\n        globalInvestEnabled = _investEnabled;\n    }\n\n    /**\n     * @notice Sets/updates the maximum number of strategies for a token\n     * @dev Only callable by governance or strategist\n     * @param _maxStrategies The new value of the maximum strategies\n     */\n    function setMaxStrategies(uint256 _maxStrategies) external onlyStrategist {\n        require(_maxStrategies > 0, \"!_maxStrategies\");\n        maxStrategies = _maxStrategies;\n    }\n\n    /**\n     * @notice Sets the address of a vault for a given token\n     * @dev Only callable by governance or strategist\n     * @param _token The address of the token\n     * @param _vault The address of the vault\n     */\n    function setVault(address _token, address _vault) external onlyStrategist {\n        require(vaults[_token] == address(0), \"vault\");\n        vaults[_token] = _vault;\n        vaultTokens[_vault] = _token;\n    }\n\n    /**\n     * @notice Withdraws all funds from a strategy\n     * @dev Only callable by governance or the strategist\n     * @param _strategy The address of the strategy\n     */\n    function withdrawAll(address _strategy) external onlyStrategist {\n        // WithdrawAll sends 'want' to 'vault'\n        IStrategy(_strategy).withdrawAll();\n    }\n\n    /**\n     * (GOVERNANCE|STRATEGIST|HARVESTER)-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Harvests the specified strategy\n     * @dev Only callable by governance, the strategist, or the harvester\n     * @param _strategy The address of the strategy\n     */\n    function harvestStrategy(address _strategy) external override onlyHarvester {\n        IStrategy(_strategy).harvest();\n        emit Harvest(_strategy);\n    }\n\n    /**\n     * VAULT-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Invests funds into a strategy\n     * @dev Only callable by a vault\n     * @param _token The address of the token\n     * @param _amount The amount that will be invested\n     */\n    function earn(address _token, uint256 _amount) external override onlyVault(_token) {\n        // get the first strategy that will accept the deposit\n        address _strategy = getBestStrategyEarn(_token, _amount);\n        // get the want token of the strategy\n        address _want = IStrategy(_strategy).want();\n        // if the depositing token is not what the strategy wants, convert it\n        // then transfer it to the strategy\n        if (_want != _token) {\n            address _converter = converters[_token][_want];\n            IERC20(_token).safeTransfer(_converter, _amount);\n            _amount = IConverter(_converter).convert(\n                _token,\n                _want,\n                _amount\n            );\n            IERC20(_want).safeTransfer(_strategy, _amount);\n        } else {\n            IERC20(_token).safeTransfer(_strategy, _amount);\n        }\n        // call the strategy's deposit function\n        IStrategy(_strategy).deposit();\n        emit Earn(_strategy);\n    }\n\n    /**\n     * @notice Withdraws funds from a strategy\n     * @dev Only callable by a vault\n     * @dev If the withdraw amount is greater than the first strategy given\n     * by getBestStrategyWithdraw, this function will loop over strategies\n     * until the requested amount is met.\n     * @param _token The address of the token\n     * @param _amount The amount that will be withdrawn\n     */\n    function withdraw(address _token, uint256 _amount) external override onlyVault(_token) {\n        (\n            address[] memory _strategies,\n            uint256[] memory _amounts\n        ) = getBestStrategyWithdraw(_token, _amount);\n        for (uint i = 0; i < _strategies.length; i++) {\n            // getBestStrategyWithdraw will return arrays larger than needed\n            // if this happens, simply exit the loop\n            if (_strategies[i] == address(0)) {\n                break;\n            }\n            IStrategy(_strategies[i]).withdraw(_amounts[i]);\n        }\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the balance of the sum of all strategies for a given token\n     * @dev This function would make deposits more expensive for the more strategies\n     * that are added for a given token\n     * @param _token The address of the token\n     */\n    function balanceOf(address _token) external view override returns (uint256 _balance) {\n        uint256 k = tokenStrategies[_token].strategies.length;\n        for (uint i = 0; i < k; i++) {\n            IStrategy _strategy = IStrategy(tokenStrategies[_token].strategies[i]);\n            address _want = _strategy.want();\n            if (_want != _token) {\n                address _converter = converters[_token][_want];\n                _balance = _balance.add(IConverter(_converter).convert_rate(\n                    _want,\n                    _token,\n                    _strategy.balanceOf()\n               ));\n            } else {\n                _balance = _balance.add(_strategy.balanceOf());\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the cap of a strategy for a given token\n     * @param _token The address of the token\n     * @param _strategy The address of the strategy\n     */\n    function getCap(address _token, address _strategy) external view returns (uint256) {\n        return tokenStrategies[_token].caps[_strategy];\n    }\n\n    /**\n     * @notice Returns whether investing is enabled for the calling vault\n     * @dev Should be called by the vault\n     */\n    function investEnabled() external view override returns (bool) {\n        if (globalInvestEnabled) {\n            return tokenStrategies[vaultTokens[msg.sender]].strategies.length > 0;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Returns all the strategies for a given token\n     * @param _token The address of the token\n     */\n    function strategies(address _token) external view returns (address[] memory) {\n        return tokenStrategies[_token].strategies;\n    }\n\n    /**\n     * @notice Returns the want address of a given token\n     * @dev Since strategies can have different want tokens, default to using the\n     * want token of the vault for a given token.\n     * @param _token The address of the token\n     */\n    function want(address _token) external view override returns (address) {\n        return IMetaVault(vaults[_token]).want();\n    }\n\n    /**\n     * @notice Returns the fee for withdrawing a specified amount\n     * @param _amount The amount that will be withdrawn\n     */\n    function withdrawFee(\n        address,\n        uint256 _amount\n    ) external view override returns (uint256 _fee) {\n        return vaultManager.withdrawalProtectionFee().mul(_amount).div(10000);\n    }\n\n    /**\n     * PUBLIC VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the best (optimistic) strategy for funds to be sent to with earn\n     * @param _token The address of the token\n     * @param _amount The amount that will be invested\n     */\n    function getBestStrategyEarn(\n        address _token,\n        uint256 _amount\n    ) public view returns (address _strategy) {\n        // get the index of the last strategy\n        uint256 k = tokenStrategies[_token].strategies.length;\n        // scan backwards from the index to the beginning of strategies\n        for (uint i = k; i > 0; i--) {\n            _strategy = tokenStrategies[_token].strategies[i - 1];\n            // get the new balance if the _amount were added to the strategy\n            uint256 balance = IStrategy(_strategy).balanceOf().add(_amount);\n            uint256 cap = tokenStrategies[_token].caps[_strategy];\n            // stop scanning if the deposit wouldn't go over the cap\n            if (balance <= cap || cap == 0) {\n                break;\n            }\n        }\n        // if never broken from the loop, use the last scanned strategy\n        // this could cause it to go over cap if (for some reason) no strategies\n        // were added with 0 cap\n    }\n\n    /**\n     * @notice Returns the best (optimistic) strategy for funds to be withdrawn from\n     * @dev Since Solidity doesn't support dynamic arrays in memory, the returned arrays\n     * from this function will always be the same length as the amount of strategies for\n     * a token. Check that _strategies[i] != address(0) when consuming to know when to\n     * break out of the loop.\n     * @param _token The address of the token\n     * @param _amount The amount that will be withdrawn\n     */\n    function getBestStrategyWithdraw(\n        address _token,\n        uint256 _amount\n    ) public view returns (\n        address[] memory _strategies,\n        uint256[] memory _amounts\n    ) {\n        // get the length of strategies\n        uint256 k = tokenStrategies[_token].strategies.length;\n        // initialize fixed-length memory arrays\n        _strategies = new address[](k);\n        _amounts = new uint256[](k);\n        // scan forward from the the beginning of strategies\n        for (uint i = 0; i < k; i++) {\n            address _strategy = tokenStrategies[_token].strategies[i];\n            _strategies[i] = _strategy;\n            // get the balance of the strategy\n            uint256 _balance = IStrategy(_strategy).balanceOf();\n            // if the strategy doesn't have the balance to cover the withdraw\n            if (_balance < _amount) {\n                // withdraw what we can and add to the _amounts\n                _amounts[i] = _balance;\n                _amount = _amount.sub(_balance);\n            } else {\n                // stop scanning if the balance is more than the withdraw amount\n                _amounts[i] = _amount;\n                break;\n            }\n        }\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    modifier onlyGovernance() {\n        require(msg.sender == vaultManager.governance(), \"!governance\");\n        _;\n    }\n\n    modifier onlyStrategist() {\n        require(msg.sender == vaultManager.strategist()\n             || msg.sender == vaultManager.governance(),\n             \"!strategist\"\n        );\n        _;\n    }\n\n    modifier onlyHarvester() {\n        require(\n            msg.sender == vaultManager.harvester() ||\n            msg.sender == vaultManager.strategist() ||\n            msg.sender == vaultManager.governance(),\n            \"!harvester\"\n        );\n        _;\n    }\n\n    modifier onlyVault(address _token) {\n        require(msg.sender == vaults[_token], \"!vault\");\n        _;\n    }\n}\n"
    },
    "contracts/metavault/IConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\ninterface IConverter {\n    function token() external view returns (address _share);\n    function convert(\n        address _input,\n        address _output,\n        uint _inputAmount\n    ) external returns (uint _outputAmount);\n    function convert_rate(\n        address _input,\n        address _output,\n        uint _inputAmount\n    ) external view returns (uint _outputAmount);\n    function convert_stables(\n        uint[3] calldata amounts\n    ) external returns (uint _shareAmount); // 0: DAI, 1: USDC, 2: USDT\n    function calc_token_amount(\n        uint[3] calldata amounts,\n        bool deposit\n    ) external view returns (uint _shareAmount);\n    function calc_token_amount_withdraw(\n        uint _shares,\n        address _output\n    ) external view returns (uint _outputAmount);\n    function setStrategy(address _strategy, bool _status) external;\n}\n"
    },
    "contracts/metavault/IMetaVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\ninterface IMetaVault {\n    function balance() external view returns (uint);\n    function setController(address _controller) external;\n    function claimInsurance() external;\n    function token() external view returns (address);\n    function available() external view returns (uint);\n    function withdrawFee(uint _amount) external view returns (uint);\n    function earn() external;\n    function calc_token_amount_deposit(uint[3] calldata amounts) external view returns (uint);\n    function calc_token_amount_withdraw(uint _shares, address _output) external view returns (uint);\n    function convert_rate(address _input, uint _amount) external view returns (uint);\n    function deposit(uint _amount, address _input, uint _min_mint_amount, bool _isStake) external;\n    function harvest(address reserve, uint amount) external;\n    function withdraw(uint _shares, address _output) external;\n    function want() external view returns (address);\n    function getPricePerFullShare() external view returns (uint);\n}\n"
    },
    "contracts/metavault/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IStrategy {\n    function balanceOf() external view returns (uint256);\n    function balanceOfPool() external view returns (uint256);\n    function balanceOfWant() external view returns (uint256);\n    function deposit() external;\n    function harvest() external;\n    function name() external view returns (string memory);\n    function skim() external;\n    function want() external view returns (address);\n    function withdraw(address) external;\n    function withdraw(uint256) external;\n    function withdrawAll() external;\n}\n"
    },
    "contracts/metavault/strategies/BaseStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../IStableSwap3Pool.sol\";\nimport \"../ISwap.sol\";\nimport \"../IVaultManager.sol\";\nimport \"../IStrategy.sol\";\nimport \"../IController.sol\";\n\n/**\n * @title BaseStrategy\n * @notice The BaseStrategy is an abstract contract which all\n * yAxis strategies should inherit functionality from. It gives\n * specific security properties which make it hard to write an\n * insecure strategy.\n * @notice All state-changing functions implemented in the strategy\n * should be internal, since any public or externally-facing functions\n * are already handled in the BaseStrategy.\n * @notice The following functions must be implemented by a strategy:\n * - function _deposit() internal virtual;\n * - function _harvest() internal virtual;\n * - function _withdraw(uint256 _amount) internal virtual;\n * - function _withdrawAll() internal virtual;\n * - function balanceOfPool() public view override virtual returns (uint256);\n */\nabstract contract BaseStrategy is IStrategy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 public constant ONE_HUNDRED_PERCENT = 10000;\n\n    address public immutable override want;\n    address public immutable weth;\n    address public immutable controller;\n    IVaultManager public immutable vaultManager;\n\n    string public override name;\n    ISwap public router;\n\n    event ApproveForSpender(address token, address spender, uint256 amount);\n    event SetController(address controller);\n    event SetRouter(address router);\n    event Skim();\n    event Withdraw(address vault, uint256 amount);\n\n    /**\n     * @param _controller The address of the controller\n     * @param _vaultManager The address of the vaultManager\n     * @param _want The desired token of the strategy\n     * @param _weth The address of WETH\n     * @param _router The address of the router for swapping tokens\n     */\n    constructor(\n        string memory _name,\n        address _controller,\n        address _vaultManager,\n        address _want,\n        address _weth,\n        address _router\n    ) public {\n        require(_controller != address(0), \"!_controller\");\n        require(_vaultManager != address(0), \"!_vaultManager\");\n        require(_want != address(0), \"!_want\");\n        require(_weth != address(0), \"!_weth\");\n        require(_router != address(0), \"!_router\");\n        name = _name;\n        want = _want;\n        controller = _controller;\n        vaultManager = IVaultManager(_vaultManager);\n        weth = _weth;\n        router = ISwap(_router);\n        IERC20(_weth).safeApprove(address(_router), type(uint256).max);\n    }\n\n    /**\n     * GOVERNANCE-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Approves a token address to be spent by an address\n     * @param _token The address of the token\n     * @param _spender The address of the spender\n     * @param _amount The amount to spend\n     */\n    function approveForSpender(IERC20 _token, address _spender, uint256 _amount) external {\n        require(msg.sender == vaultManager.governance(), \"!governance\");\n        _token.safeApprove(_spender, _amount);\n        emit ApproveForSpender(address(_token), _spender, _amount);\n    }\n\n    /**\n     * @notice Sets the address of the ISwap-compatible router\n     * @param _router The address of the router\n     */\n    function setRouter(address _router) external {\n        require(msg.sender == vaultManager.governance(), \"!governance\");\n        router = ISwap(_router);\n        IERC20(weth).safeApprove(address(_router), 0);\n        IERC20(weth).safeApprove(address(_router), type(uint256).max);\n        emit SetRouter(_router);\n    }\n\n    /**\n     * AUTHORIZED-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Deposits funds to the strategy's pool\n     */\n    function deposit() external override onlyAuthorized {\n        _deposit();\n    }\n\n    /**\n     * @notice Harvest funds in the strategy's pool\n     */\n    function harvest() external override onlyAuthorized {\n        _harvest();\n    }\n\n    /**\n     * @notice Sends stuck want tokens in the strategy to the controller\n     */\n    function skim() external override onlyAuthorized {\n        IERC20(want).safeTransfer(controller, balanceOfWant());\n        emit Skim();\n    }\n\n    /**\n     * @notice Sends stuck tokens in the strategy to the controller\n     * @param _asset The address of the token to withdraw\n     */\n    function withdraw(address _asset) external override onlyAuthorized {\n        require(want != _asset, \"want\");\n\n        IERC20 _assetToken = IERC20(_asset);\n        uint256 _balance = _assetToken.balanceOf(address(this));\n        _assetToken.safeTransfer(controller, _balance);\n    }\n\n    /**\n     * @notice Initiated from a vault, withdraws funds from the pool\n     * @param _amount The amount of the want token to withdraw\n     */\n    function withdraw(uint256 _amount) external override onlyAuthorized {\n        uint256 _balance = balanceOfWant();\n        if (_balance < _amount) {\n            _amount = _withdrawSome(_amount.sub(_balance));\n            _amount = _amount.add(_balance);\n        }\n\n        address _token = _vaultWant();\n        address _vault = IController(controller).vaults(_token);\n        require(_vault != address(0), \"!vault\"); // additional protection so we don't burn the funds\n        IERC20(_token).safeTransfer(_vault, _amount);\n        emit Withdraw(_vault, _amount);\n    }\n\n    /**\n     * @notice Withdraws all funds from the strategy\n     */\n    function withdrawAll() external override onlyAuthorized {\n        _withdrawAll();\n\n        address _token = _vaultWant();\n        uint256 _balance = IERC20(_token).balanceOf(address(this));\n\n        address _vault = IController(controller).vaults(_token);\n        require(_vault != address(0), \"!vault\"); // additional protection so we don't burn the funds\n        IERC20(_token).safeTransfer(_vault, _balance);\n        emit Withdraw(_vault, _balance);\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the strategy's balance of the want token plus the balance of pool\n     */\n    function balanceOf() external override view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    /**\n     * PUBLIC VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the balance of the pool\n     * @dev Must be implemented by the strategy\n     */\n    function balanceOfPool() public view override virtual returns (uint256);\n\n    /**\n     * @notice Returns the balance of the want token on the strategy\n     */\n    function balanceOfWant() public view override returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    /**\n     * INTERNAL FUNCTIONS\n     */\n\n    function _deposit() internal virtual;\n\n    function _harvest() internal virtual;\n\n    function _payHarvestFees(\n        address _poolToken\n    ) internal returns (uint256 _wethBal) {\n        uint256 _amount = IERC20(_poolToken).balanceOf(address(this));\n        _swapTokens(_poolToken, weth, _amount);\n        _wethBal = IERC20(weth).balanceOf(address(this));\n\n        if (_wethBal > 0) {\n            // get all the necessary variables in a single call\n            (\n                address yax,\n                address stakingPool,\n                uint256 stakingPoolShareFee,\n                address treasury,\n                uint256 treasuryFee,\n                address insurance,\n                uint256 insurancePoolFee\n            ) = vaultManager.getHarvestFeeInfo();\n\n            uint256 _fee;\n\n            // pay the staking pool with YAX\n            if (stakingPoolShareFee > 0 && stakingPool != address(0)) {\n                _fee = _wethBal.mul(stakingPoolShareFee).div(ONE_HUNDRED_PERCENT);\n                _swapTokens(weth, yax, _fee);\n                IERC20(yax).safeTransfer(stakingPool, IERC20(yax).balanceOf(address(this)));\n            }\n\n            // pay the treasury with YAX\n            if (treasuryFee > 0 && treasury != address(0)) {\n                _fee = _wethBal.mul(treasuryFee).div(ONE_HUNDRED_PERCENT);\n                _swapTokens(weth, yax, _fee);\n                IERC20(yax).safeTransfer(treasury, IERC20(yax).balanceOf(address(this)));\n            }\n\n            // pay the insurance pool with YAX\n            if (insurancePoolFee > 0 && insurance != address(0)) {\n                _fee = _wethBal.mul(insurancePoolFee).div(ONE_HUNDRED_PERCENT);\n                _swapTokens(weth, yax, _fee);\n                IERC20(yax).safeTransfer(insurance, IERC20(yax).balanceOf(address(this)));\n            }\n\n            // return the remaining WETH balance\n            _wethBal = IERC20(weth).balanceOf(address(this));\n        }\n    }\n\n    function _swapTokens(address _input, address _output, uint256 _amount) internal {\n        address[] memory path = new address[](2);\n        path[0] = _input;\n        path[1] = _output;\n        router.swapExactTokensForTokens(\n            _amount,\n            1,\n            path,\n            address(this),\n            // solhint-disable-next-line not-rely-on-time\n            block.timestamp.add(1800)\n        );\n    }\n\n    function _vaultWant() internal returns (address) {\n        return IController(controller).strategyTokens(address(this));\n    }\n\n    function _withdraw(uint256 _amount) internal virtual;\n\n    function _withdrawAll() internal virtual;\n\n    function _withdrawSome(uint256 _amount) internal returns (uint256) {\n        address _token = _vaultWant();\n        uint256 _before = IERC20(_token).balanceOf(address(this));\n        _withdraw(_amount);\n        uint256 _after = IERC20(_token).balanceOf(address(this));\n        _amount = _after.sub(_before);\n\n        return _amount;\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    modifier onlyAuthorized() {\n        require(msg.sender == controller\n             || msg.sender == vaultManager.strategist()\n             || msg.sender == vaultManager.governance(),\n             \"!authorized\"\n        );\n        _;\n    }\n}\n"
    },
    "contracts/metavault/IStableSwap3Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\ninterface IStableSwap3Pool {\n    function get_virtual_price() external view returns (uint);\n    function balances(uint) external view returns (uint);\n    function get_dy(int128 i, int128 j, uint dx) external view returns (uint dy);\n    function exchange(int128 i, int128 j, uint dx, uint min_dy) external;\n    function add_liquidity(uint[3] calldata amounts, uint min_mint_amount) external;\n    function remove_liquidity(uint _amount, uint[3] calldata amounts) external;\n    function remove_liquidity_one_coin(uint _token_amount, int128 i, uint min_amount) external;\n    function calc_token_amount(uint[3] calldata amounts, bool deposit) external view returns (uint);\n    function calc_withdraw_one_coin(uint _token_amount, int128 i) external view returns (uint);\n}\n"
    },
    "contracts/metavault/ISwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\ninterface ISwap {\n    function swapExactTokensForTokens(uint256, uint256, address[] calldata, address, uint256) external;\n}\n"
    },
    "contracts/metavault/strategies/StrategyYearnV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"../../interfaces/YearnV2.sol\";\nimport \"../IConverter.sol\";\nimport \"./BaseStrategy.sol\";\n\ncontract StrategyYearnV2 is BaseStrategy {\n    address public immutable yvToken;\n    IConverter public converter;\n\n    constructor(\n        string memory _name,\n        address _yvToken,\n        address _underlying,\n        address _converter,\n        address _controller,\n        address _vaultManager,\n        address _weth,\n        address _router\n    )\n        public\n        BaseStrategy(\n            _name,\n            _controller,\n            _vaultManager,\n            _underlying,\n            _weth,\n            _router\n        )\n    {\n        require(_yvToken != address(0), \"!_yvToken\");\n        require(_converter != address(0), \"!_converter\");\n        yvToken = _yvToken;\n        converter = IConverter(_converter);\n        IERC20(_underlying).safeApprove(_converter, type(uint256).max);\n        IERC20(_underlying).safeApprove(_yvToken, type(uint256).max);\n    }\n\n    function balanceOfPool() public view override returns (uint256) {\n        if (ERC20(yvToken).totalSupply() == 0) {\n            return 0;\n        }\n        uint256 balance = IERC20(yvToken).balanceOf(address(this));\n        return balance\n            .mul(IYearnV2Vault(yvToken).pricePerShare())\n            .div(1e18);\n    }\n\n    function _deposit() internal override {\n        IYearnV2Vault(yvToken).deposit();\n    }\n\n    function _harvest() internal override {\n        // TODO: add a way to harvest the interest earned amount\n        return;\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        IYearnV2Vault vaultToken = IYearnV2Vault(yvToken);\n        _amount = _amount.mul(1e18).div(vaultToken.pricePerShare());\n        vaultToken.withdraw(_amount);\n        _amount = balanceOfWant();\n        if (_amount > 0) {\n            _convert(want, _vaultWant(), _amount);\n        }\n    }\n\n    function _withdrawAll() internal override {\n        uint256 balance = IERC20(yvToken).balanceOf(address(this));\n        IYearnV2Vault(yvToken).withdraw();\n\n        balance = balanceOfWant();\n        if (balance > 0) {\n            _convert(want, _vaultWant(), balance);\n        }\n    }\n\n    function _convert(address _from, address _to, uint256 _amount) internal {\n        require(converter.convert_rate(_from, _to, _amount) > 0, \"!convert_rate\");\n        IERC20(_from).safeTransfer(address(converter), _amount);\n        converter.convert(_from, _to, _amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/interfaces/YearnV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\ninterface IYearnV2Vault {\n    function deposit(uint256 amount) external returns (uint256);\n    function deposit() external returns (uint256);\n    function withdraw(uint256 shares) external;\n    function withdraw() external;\n    function pricePerShare() external view returns (uint256);\n    function token() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/metavault/yAxisMetaVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\n\nimport \"./IVaultManager.sol\";\nimport \"./IController.sol\";\nimport \"./IConverter.sol\";\nimport \"./IMetaVault.sol\";\n\n/**\n * @title yAxisMetaVault\n * @notice The metavault is where users deposit and withdraw stablecoins\n * @dev This metavault will pay YAX incentive for depositors and stakers\n * It does not need minter key of YAX. Governance multisig will mint total\n * of 34000 YAX and send into the vault in the beginning\n */\ncontract yAxisMetaVault is ERC20, IMetaVault {\n    using Address for address;\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    IERC20[4] public inputTokens; // DAI, USDC, USDT, 3Crv\n\n    IERC20 public token3CRV;\n    IERC20 public tokenYAX;\n\n    uint public min = 9500;\n    uint public constant max = 10000;\n\n    uint public earnLowerlimit = 5 ether; // minimum to invest is 5 3CRV\n    uint public totalDepositCap = 10000000 ether; // initial cap set at 10 million dollar\n\n    address public governance;\n    address public controller;\n    uint public insurance;\n    IVaultManager public vaultManager;\n    IConverter public converter;\n\n    bool public acceptContractDepositor = false; // dont accept contract at beginning\n\n    struct UserInfo {\n        uint amount;\n        uint yaxRewardDebt;\n        uint accEarned;\n    }\n\n    uint public lastRewardBlock;\n    uint public accYaxPerShare;\n\n    uint public yaxPerBlock;\n\n    mapping(address => UserInfo) public userInfo;\n\n    address public treasuryWallet = 0x362Db1c17db4C79B51Fe6aD2d73165b1fe9BaB4a;\n\n    uint public constant BLOCKS_PER_WEEK = 46500;\n\n    // Block number when each epoch ends.\n    uint[5] public epochEndBlocks;\n\n    // Reward multipler for each of 5 epoches (epochIndex: reward multipler)\n    uint[6] public epochRewardMultiplers = [86000, 64000, 43000, 21000, 10000, 1];\n\n    /**\n     * @notice Emitted when a user deposits funds\n     */\n    event Deposit(address indexed user, uint amount);\n\n    /**\n     * @notice Emitted when a user withdraws funds\n     */\n    event Withdraw(address indexed user, uint amount);\n\n    /**\n     * @notice Emitted when YAX is paid to a user\n     */\n    event RewardPaid(address indexed user, uint reward);\n\n    /**\n     * @param _tokenDAI The address of the DAI token\n     * @param _tokenUSDC The address of the USDC token\n     * @param _tokenUSDT The address of the USDT token\n     * @param _token3CRV The address of the 3CRV token\n     * @param _tokenYAX The address of the YAX token\n     * @param _yaxPerBlock The amount of YAX rewarded per block\n     * @param _startBlock The starting block for rewards\n     */\n    constructor (IERC20 _tokenDAI, IERC20 _tokenUSDC, IERC20 _tokenUSDT, IERC20 _token3CRV, IERC20 _tokenYAX,\n        uint _yaxPerBlock, uint _startBlock) public ERC20(\"yAxis.io:MetaVault:3CRV\", \"MVLT\") {\n        inputTokens[0] = _tokenDAI;\n        inputTokens[1] = _tokenUSDC;\n        inputTokens[2] = _tokenUSDT;\n        inputTokens[3] = _token3CRV;\n        token3CRV = _token3CRV;\n        tokenYAX = _tokenYAX;\n        yaxPerBlock = _yaxPerBlock; // supposed to be 0.000001 YAX (1000000000000 = 1e12 wei)\n        lastRewardBlock = (_startBlock > block.number) ? _startBlock : block.number; // supposed to be 11,163,000 (Sat Oct 31 2020 06:30:00 GMT+0)\n        epochEndBlocks[0] = lastRewardBlock + BLOCKS_PER_WEEK * 2; // weeks 1-2\n        epochEndBlocks[1] = epochEndBlocks[0] + BLOCKS_PER_WEEK * 2; // weeks 3-4\n        epochEndBlocks[2] = epochEndBlocks[1] + BLOCKS_PER_WEEK * 4; // month 2\n        epochEndBlocks[3] = epochEndBlocks[2] + BLOCKS_PER_WEEK * 8; // month 3-4\n        epochEndBlocks[4] = epochEndBlocks[3] + BLOCKS_PER_WEEK * 8; // month 5-6\n        governance = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by a contract and we are not allowing.\n     */\n    modifier checkContract() {\n        if (!acceptContractDepositor) {\n            require(!address(msg.sender).isContract() && msg.sender == tx.origin, \"Sorry we do not accept contract!\");\n        }\n        _;\n    }\n\n    /**\n     * @notice Returns the current token3CRV balance of the vault and controller, minus insurance\n     * @dev Ignore insurance fund for balance calculations\n     */\n    function balance() public override view returns (uint) {\n        uint bal = token3CRV.balanceOf(address(this));\n        if (controller != address(0)) bal = bal.add(IController(controller).balanceOf(address(token3CRV)));\n        return bal.sub(insurance);\n    }\n\n    /**\n     * @notice Called by Governance to set the value for min\n     * @param _min The new min value\n     */\n    function setMin(uint _min) external {\n        require(msg.sender == governance, \"!governance\");\n        min = _min;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the governance address\n     * @param _governance The new governance value\n     */\n    function setGovernance(address _governance) public {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the controller address\n     * @param _controller The new controller value\n     */\n    function setController(address _controller) public override {\n        require(msg.sender == governance, \"!governance\");\n        controller = _controller;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the converter address\n     * @param _converter The new converter value\n     * @dev Requires that the return address of token() from the converter is the\n     * same as token3CRV\n     */\n    function setConverter(IConverter _converter) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_converter.token() == address(token3CRV), \"!token3CRV\");\n        converter = _converter;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the vaultManager address\n     * @param _vaultManager The new vaultManager value\n     */\n    function setVaultManager(IVaultManager _vaultManager) public {\n        require(msg.sender == governance, \"!governance\");\n        vaultManager = _vaultManager;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the earnLowerlimit\n     * @dev earnLowerlimit determines the minimum balance of this contract for earn\n     * to be called\n     * @param _earnLowerlimit The new earnLowerlimit value\n     */\n    function setEarnLowerlimit(uint _earnLowerlimit) public {\n        require(msg.sender == governance, \"!governance\");\n        earnLowerlimit = _earnLowerlimit;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the totalDepositCap\n     * @dev totalDepositCap is the maximum amount of value that can be deposited\n     * to the metavault at a time\n     * @param _totalDepositCap The new totalDepositCap value\n     */\n    function setTotalDepositCap(uint _totalDepositCap) public {\n        require(msg.sender == governance, \"!governance\");\n        totalDepositCap = _totalDepositCap;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for acceptContractDepositor\n     * @dev acceptContractDepositor allows the metavault to accept deposits from\n     * smart contract addresses\n     * @param _acceptContractDepositor The new acceptContractDepositor value\n     */\n    function setAcceptContractDepositor(bool _acceptContractDepositor) public {\n        require(msg.sender == governance, \"!governance\");\n        acceptContractDepositor = _acceptContractDepositor;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for yaxPerBlock\n     * @dev Makes a call to updateReward()\n     * @param _yaxPerBlock The new yaxPerBlock value\n     */\n    function setYaxPerBlock(uint _yaxPerBlock) public {\n        require(msg.sender == governance, \"!governance\");\n        updateReward();\n        yaxPerBlock = _yaxPerBlock;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for epochEndBlocks at the given index\n     * @dev Throws if _index >= 5\n     * @dev Throws if _epochEndBlock > the current block.number\n     * @dev Throws if the stored block.number at the given index is > the current block.number\n     * @param _index The index to set of epochEndBlocks\n     * @param _epochEndBlock The new epochEndBlocks value at the index\n     */\n    function setEpochEndBlock(uint8 _index, uint256 _epochEndBlock) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_index < 5, \"_index out of range\");\n        require(_epochEndBlock > block.number, \"Too late to update\");\n        require(epochEndBlocks[_index] > block.number, \"Too late to update\");\n        epochEndBlocks[_index] = _epochEndBlock;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for epochRewardMultiplers at the given index\n     * @dev Throws if _index < 1 or > 5\n     * @dev Throws if the stored block.number at the previous index is > the current block.number\n     * @param _index The index to set of epochRewardMultiplers\n     * @param _epochRewardMultipler The new epochRewardMultiplers value at the index\n     */\n    function setEpochRewardMultipler(uint8 _index, uint256 _epochRewardMultipler) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_index > 0 && _index < 6, \"Index out of range\");\n        require(epochEndBlocks[_index - 1] > block.number, \"Too late to update\");\n        epochRewardMultiplers[_index] = _epochRewardMultipler;\n    }\n\n    /**\n     * @notice Return reward multiplier over the given _from to _to block.\n     * @param _from The from block\n     * @param _to The to block\n     */\n    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\n        // start at the end of the epochs\n        for (uint8 epochId = 5; epochId >= 1; --epochId) {\n            // if _to (the current block number if called within this contract) is after the previous epoch ends\n            if (_to >= epochEndBlocks[epochId - 1]) {\n                // if the last reward block is after the previous epoch: return the number of blocks multiplied by this epochs multiplier\n                if (_from >= epochEndBlocks[epochId - 1]) return _to.sub(_from).mul(epochRewardMultiplers[epochId]);\n                // get the multiplier amount for the remaining reward of the current epoch\n                uint256 multiplier = _to.sub(epochEndBlocks[epochId - 1]).mul(epochRewardMultiplers[epochId]);\n                // if epoch is 1: return the remaining current epoch reward with the first epoch reward\n                if (epochId == 1) return multiplier.add(epochEndBlocks[0].sub(_from).mul(epochRewardMultiplers[0]));\n                // for all epochs in between the first and current epoch\n                for (epochId = epochId - 1; epochId >= 1; --epochId) {\n                    // if the last reward block is after the previous epoch: return the current remaining reward with the previous epoch\n                    if (_from >= epochEndBlocks[epochId - 1]) return multiplier.add(epochEndBlocks[epochId].sub(_from).mul(epochRewardMultiplers[epochId]));\n                    // accumulate the multipler with the reward from the epoch\n                    multiplier = multiplier.add(epochEndBlocks[epochId].sub(epochEndBlocks[epochId - 1]).mul(epochRewardMultiplers[epochId]));\n                }\n                // return the accumulated multiplier with the reward from the first epoch\n                return multiplier.add(epochEndBlocks[0].sub(_from).mul(epochRewardMultiplers[0]));\n            }\n        }\n        // return the reward amount between _from and _to in the first epoch\n        return _to.sub(_from).mul(epochRewardMultiplers[0]);\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the treasuryWallet\n     * @param _treasuryWallet The new treasuryWallet value\n     */\n    function setTreasuryWallet(address _treasuryWallet) public {\n        require(msg.sender == governance, \"!governance\");\n        treasuryWallet = _treasuryWallet;\n    }\n\n    /**\n     * @notice Called by Governance or the controller to claim the amount stored in the insurance fund\n     * @dev If called by the controller, insurance will auto compound the vault, increasing getPricePerFullShare\n     */\n    function claimInsurance() external override {\n        // if claim by controller for auto-compounding (current insurance will stay to increase sharePrice)\n        // otherwise send the fund to treasuryWallet\n        if (msg.sender != controller) {\n            // claim by governance for insurance\n            require(msg.sender == governance, \"!governance\");\n            token3CRV.safeTransfer(treasuryWallet, insurance);\n        }\n        insurance = 0;\n    }\n\n    /**\n     * @notice Get the address of the 3CRV token\n     */\n    function token() public override view returns (address) {\n        return address(token3CRV);\n    }\n\n    /**\n     * @notice Get the amount that the metavault allows to be borrowed\n     * @dev min and max are used to keep small withdrawals cheap\n     */\n    function available() public override view returns (uint) {\n        return token3CRV.balanceOf(address(this)).mul(min).div(max);\n    }\n\n    /**\n     * @notice If the controller is set, returns the withdrawFee of the 3CRV token for the given _amount\n     * @param _amount The amount being queried to withdraw\n     */\n    function withdrawFee(uint _amount) public override view returns (uint) {\n        return (controller == address(0)) ? 0 : IController(controller).withdrawFee(address(token3CRV), _amount);\n    }\n\n    /**\n     * @notice Sends accrued 3CRV tokens on the metavault to the controller to be deposited to strategies\n     */\n    function earn() public override {\n        if (controller != address(0)) {\n            IController _contrl = IController(controller);\n            if (_contrl.investEnabled()) {\n                uint _bal = available();\n                token3CRV.safeTransfer(controller, _bal);\n                _contrl.earn(address(token3CRV), _bal);\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the amount of 3CRV given for the amounts deposited\n     * @param amounts The stablecoin amounts being deposited\n     */\n    function calc_token_amount_deposit(uint[3] calldata amounts) external override view returns (uint) {\n        return converter.calc_token_amount(amounts, true);\n    }\n\n    /**\n     * @notice Returns the amount given in the desired token for the given shares\n     * @param _shares The amount of shares to withdraw\n     * @param _output The desired token to withdraw\n     */\n    function calc_token_amount_withdraw(uint _shares, address _output) external override view returns (uint) {\n        uint _withdrawFee = withdrawFee(_shares);\n        if (_withdrawFee > 0) {\n            _shares = _shares.mul(10000 - _withdrawFee).div(10000);\n        }\n        uint r = (balance().mul(_shares)).div(totalSupply());\n        if (_output == address(token3CRV)) {\n            return r;\n        }\n        return converter.calc_token_amount_withdraw(r, _output);\n    }\n\n    /**\n     * @notice Returns the amount of 3CRV that would be given for the amount of input tokens\n     * @param _input The stablecoin to convert to 3CRV\n     * @param _amount The amount of stablecoin to convert\n     */\n    function convert_rate(address _input, uint _amount) external override view returns (uint) {\n        return converter.convert_rate(_input, address(token3CRV), _amount);\n    }\n\n    /**\n     * @notice Deposit a single stablecoin to the metavault\n     * @dev Users must approve the metavault to spend their stablecoin\n     * @param _amount The amount of the stablecoin to deposit\n     * @param _input The address of the stablecoin being deposited\n     * @param _min_mint_amount The expected amount of shares to receive\n     * @param _isStake Stakes shares or not\n     */\n    function deposit(uint _amount, address _input, uint _min_mint_amount, bool _isStake) external override checkContract {\n        require(_amount > 0, \"!_amount\");\n        uint _pool = balance();\n        uint _before = token3CRV.balanceOf(address(this));\n        if (_input == address(token3CRV)) {\n            token3CRV.safeTransferFrom(msg.sender, address(this), _amount);\n        } else if (converter.convert_rate(_input, address(token3CRV), _amount) > 0) {\n            IERC20(_input).safeTransferFrom(msg.sender, address(converter), _amount);\n            converter.convert(_input, address(token3CRV), _amount);\n        }\n        uint _after = token3CRV.balanceOf(address(this));\n        require(totalDepositCap == 0 || _after <= totalDepositCap, \">totalDepositCap\");\n        _amount = _after.sub(_before); // Additional check for deflationary tokens\n        require(_amount >= _min_mint_amount, \"slippage\");\n        if (_amount > 0) {\n            if (!_isStake) {\n                _deposit(msg.sender, _pool, _amount);\n            } else {\n                uint _shares = _deposit(address(this), _pool, _amount);\n                _stakeShares(_shares);\n            }\n        }\n    }\n\n    /**\n     * @notice Deposits multiple stablecoins simultaneously to the metavault\n     * @dev 0: DAI, 1: USDC, 2: USDT, 3: 3CRV\n     * @dev Users must approve the metavault to spend their stablecoin\n     * @param _amounts The amounts of each stablecoin being deposited\n     * @param _min_mint_amount The expected amount of shares to receive\n     * @param _isStake Stakes shares or not\n     */\n    function depositAll(uint[4] calldata _amounts, uint _min_mint_amount, bool _isStake) external checkContract {\n        uint _pool = balance();\n        uint _before = token3CRV.balanceOf(address(this));\n        bool hasStables = false;\n        for (uint8 i = 0; i < 4; i++) {\n            uint _inputAmount = _amounts[i];\n            if (_inputAmount > 0) {\n                if (i == 3) {\n                    inputTokens[i].safeTransferFrom(msg.sender, address(this), _inputAmount);\n                } else if (converter.convert_rate(address(inputTokens[i]), address(token3CRV), _inputAmount) > 0) {\n                    inputTokens[i].safeTransferFrom(msg.sender, address(converter), _inputAmount);\n                    hasStables = true;\n                }\n            }\n        }\n        if (hasStables) {\n            uint[3] memory _stablesAmounts;\n            _stablesAmounts[0] = _amounts[0];\n            _stablesAmounts[1] = _amounts[1];\n            _stablesAmounts[2] = _amounts[2];\n            converter.convert_stables(_stablesAmounts);\n        }\n        uint _after = token3CRV.balanceOf(address(this));\n        require(totalDepositCap == 0 || _after <= totalDepositCap, \">totalDepositCap\");\n        uint _totalDepositAmount = _after.sub(_before); // Additional check for deflationary tokens\n        require(_totalDepositAmount >= _min_mint_amount, \"slippage\");\n        if (_totalDepositAmount > 0) {\n            if (!_isStake) {\n                _deposit(msg.sender, _pool, _totalDepositAmount);\n            } else {\n                uint _shares = _deposit(address(this), _pool, _totalDepositAmount);\n                _stakeShares(_shares);\n            }\n        }\n    }\n\n    /**\n     * @notice Stakes metavault shares\n     * @param _shares The amount of shares to stake\n     */\n    function stakeShares(uint _shares) external {\n        uint _before = balanceOf(address(this));\n        IERC20(address(this)).transferFrom(msg.sender, address(this), _shares);\n        uint _after = balanceOf(address(this));\n        _shares = _after.sub(_before);\n        // Additional check for deflationary tokens\n        _stakeShares(_shares);\n    }\n\n    function _deposit(address _mintTo, uint _pool, uint _amount) internal returns (uint _shares) {\n        if (address(vaultManager) != address(0)) {\n            // expected 0.1% of deposits go into an insurance fund (or auto-compounding if called by controller) in-case of negative profits to protect withdrawals\n            // it is updated by governance (community vote)\n            uint _insuranceFee = vaultManager.insuranceFee();\n            if (_insuranceFee > 0) {\n                uint _insurance = _amount.mul(_insuranceFee).div(10000);\n                _amount = _amount.sub(_insurance);\n                insurance = insurance.add(_insurance);\n            }\n        }\n\n        if (totalSupply() == 0) {\n            _shares = _amount;\n        } else {\n            _shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        if (_shares > 0) {\n            if (token3CRV.balanceOf(address(this)) > earnLowerlimit) {\n                earn();\n            }\n            _mint(_mintTo, _shares);\n        }\n    }\n\n    function _stakeShares(uint _shares) internal {\n        UserInfo storage user = userInfo[msg.sender];\n        updateReward();\n        _getReward();\n        user.amount = user.amount.add(_shares);\n        user.yaxRewardDebt = user.amount.mul(accYaxPerShare).div(1e12);\n        emit Deposit(msg.sender, _shares);\n    }\n\n    /**\n     * @notice Returns the pending YAXs for a given account\n     * @param _account The address to query\n     */\n    function pendingYax(address _account) public view returns (uint _pending) {\n        UserInfo storage user = userInfo[_account];\n        uint _accYaxPerShare = accYaxPerShare;\n        uint lpSupply = balanceOf(address(this));\n        if (block.number > lastRewardBlock && lpSupply != 0) {\n            uint256 _multiplier = getMultiplier(lastRewardBlock, block.number);\n            _accYaxPerShare = accYaxPerShare.add(_multiplier.mul(yaxPerBlock).mul(1e12).div(lpSupply));\n        }\n        _pending = user.amount.mul(_accYaxPerShare).div(1e12).sub(user.yaxRewardDebt);\n    }\n\n    /**\n     * @notice Sets the lastRewardBlock and accYaxPerShare\n     */\n    function updateReward() public {\n        if (block.number <= lastRewardBlock) {\n            return;\n        }\n        uint lpSupply = balanceOf(address(this));\n        if (lpSupply == 0) {\n            lastRewardBlock = block.number;\n            return;\n        }\n        uint256 _multiplier = getMultiplier(lastRewardBlock, block.number);\n        accYaxPerShare = accYaxPerShare.add(_multiplier.mul(yaxPerBlock).mul(1e12).div(lpSupply));\n        lastRewardBlock = block.number;\n    }\n\n    function _getReward() internal {\n        UserInfo storage user = userInfo[msg.sender];\n        uint _pendingYax = user.amount.mul(accYaxPerShare).div(1e12).sub(user.yaxRewardDebt);\n        if (_pendingYax > 0) {\n            user.accEarned = user.accEarned.add(_pendingYax);\n            safeYaxTransfer(msg.sender, _pendingYax);\n            emit RewardPaid(msg.sender, _pendingYax);\n        }\n    }\n\n    /**\n     * @notice Withdraw the entire balance for an account\n     * @param _output The address of the desired stablecoin to receive\n     */\n    function withdrawAll(address _output) external {\n        unstake(userInfo[msg.sender].amount);\n        withdraw(balanceOf(msg.sender), _output);\n    }\n\n    /**\n     * @notice Used to swap any borrowed reserve over the debt limit to liquidate to 'token'\n     * @param reserve The address of the token to swap to 3CRV\n     * @param amount The amount to swap\n     */\n    function harvest(address reserve, uint amount) external override {\n        require(msg.sender == controller, \"!controller\");\n        require(reserve != address(token3CRV), \"token3CRV\");\n        IERC20(reserve).safeTransfer(controller, amount);\n    }\n\n    /**\n     * @notice Unstakes the given shares from the metavault\n     * @dev call unstake(0) to only receive the reward\n     * @param _amount The amount to unstake\n     */\n    function unstake(uint _amount) public {\n        updateReward();\n        _getReward();\n        UserInfo storage user = userInfo[msg.sender];\n        if (_amount > 0) {\n            require(user.amount >= _amount, \"stakedBal < _amount\");\n            user.amount = user.amount.sub(_amount);\n            IERC20(address(this)).transfer(msg.sender, _amount);\n        }\n        user.yaxRewardDebt = user.amount.mul(accYaxPerShare).div(1e12);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Withdraws an amount of shares to a given output stablecoin\n     * @dev No rebalance implementation for lower fees and faster swaps\n     * @param _shares The amount of shares to withdraw\n     * @param _output The address of the stablecoin to receive\n     */\n    function withdraw(uint _shares, address _output) public override {\n        uint _userBal = balanceOf(msg.sender);\n        if (_shares > _userBal) {\n            uint _need = _shares.sub(_userBal);\n            require(_need <= userInfo[msg.sender].amount, \"_userBal+staked < _shares\");\n            unstake(_need);\n        }\n        uint r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        if (address(vaultManager) != address(0)) {\n            // expected 0.1% of withdrawal go back to vault (for auto-compounding) to protect withdrawals\n            // it is updated by governance (community vote)\n            uint _withdrawalProtectionFee = vaultManager.withdrawalProtectionFee();\n            if (_withdrawalProtectionFee > 0) {\n                uint _withdrawalProtection = r.mul(_withdrawalProtectionFee).div(10000);\n                r = r.sub(_withdrawalProtection);\n            }\n        }\n\n        // Check balance\n        uint b = token3CRV.balanceOf(address(this));\n        if (b < r) {\n            uint _toWithdraw = r.sub(b);\n            if (controller != address(0)) {\n                IController(controller).withdraw(address(token3CRV), _toWithdraw);\n            }\n            uint _after = token3CRV.balanceOf(address(this));\n            uint _diff = _after.sub(b);\n            if (_diff < _toWithdraw) {\n                r = b.add(_diff);\n            }\n        }\n\n        if (_output == address(token3CRV)) {\n            token3CRV.safeTransfer(msg.sender, r);\n        } else {\n            require(converter.convert_rate(address(token3CRV), _output, r) > 0, \"rate=0\");\n            token3CRV.safeTransfer(address(converter), r);\n            uint _outputAmount = converter.convert(address(token3CRV), _output, r);\n            IERC20(_output).safeTransfer(msg.sender, _outputAmount);\n        }\n    }\n\n    /**\n     * @notice Returns the address of the 3CRV token\n     */\n    function want() external override view returns (address) {\n        return address(token3CRV);\n    }\n\n    /**\n     * @notice Returns the rate of earnings of a single share\n     */\n    function getPricePerFullShare() external override view returns (uint) {\n        return balance().mul(1e18).div(totalSupply());\n    }\n\n    /**\n     * @notice Transfers YAX from the metavault to a given address\n     * @dev Ensures the metavault has enough balance to transfer\n     * @param _to The address to transfer to\n     * @param _amount The amount to transfer\n     */\n    function safeYaxTransfer(address _to, uint _amount) internal {\n        uint _tokenBal = tokenYAX.balanceOf(address(this));\n        tokenYAX.safeTransfer(_to, (_tokenBal < _amount) ? _tokenBal : _amount);\n    }\n\n    /**\n     * @notice Converts non-3CRV stablecoins held in the metavault to 3CRV\n     * @param _token The address to convert\n     */\n    function earnExtra(address _token) public {\n        require(msg.sender == governance, \"!governance\");\n        require(address(_token) != address(token3CRV), \"3crv\");\n        require(address(_token) != address(this), \"mlvt\");\n        uint _amount = IERC20(_token).balanceOf(address(this));\n        require(converter.convert_rate(_token, address(token3CRV), _amount) > 0, \"rate=0\");\n        IERC20(_token).safeTransfer(address(converter), _amount);\n        converter.convert(_token, address(token3CRV), _amount);\n    }\n}\n"
    },
    "contracts/metavault/strategies/StrategyGenericVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"../../interfaces/GenericVault.sol\";\nimport \"../IConverter.sol\";\nimport \"./BaseStrategy.sol\";\n\ncontract StrategyGenericVault is BaseStrategy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public vault;\n    IConverter public converter;\n\n    /**\n     * @param _name The name of the strategy\n     * @param _vault The address of the vault\n     * @param _converter The address of the converter\n     * @param _controller The address of the controller\n     * @param _vaultManager The address of the vaultManager\n     * @param _weth The address of WETH\n     * @param _router The address of the router for swapping tokens\n     */\n    constructor(\n        string memory _name,\n        address _vault,\n        address _converter,\n        address _controller,\n        address _vaultManager,\n        address _weth,\n        address _router\n    )\n        public\n        BaseStrategy(\n            _name,\n            _controller,\n            _vaultManager,\n            IGenericVault(_vault).token(),\n            _weth,\n            _router\n        )\n    {\n        require(_vault != address(0), \"!_vault\");\n        require(_converter != address(0), \"!_converter\");\n        vault = _vault;\n        converter = IConverter(_converter);\n        IERC20(IGenericVault(_vault).token()).safeApprove(_vault, type(uint256).max);\n    }\n\n    function _deposit() internal override {\n        uint256 _amount = balanceOfWant();\n        if (_amount > 0) {\n            IGenericVault(vault).deposit(_amount);\n        }\n    }\n\n    function _harvest() internal override {\n        // Harvest is not necessary for generic vaults\n        return;\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        _amount = _amount.mul(1e18).div(getPricePerFullShare());\n        IGenericVault(vault).withdraw(_amount);\n        _amount = balanceOfWant();\n        if (_amount > 0) {\n            _convert(want, _vaultWant(), _amount);\n        }\n    }\n\n    function _withdrawAll() internal override {\n        uint256 _amount = IERC20(vault).balanceOf(address(this));\n        if (_amount > 0) {\n            IGenericVault(vault).withdrawAll();\n            _amount = balanceOfWant();\n            _convert(want, _vaultWant(), _amount);\n        }\n    }\n\n    // Allow overrideing to implement fee\n    function balanceOfPool() public view virtual override returns (uint256) {\n        if (ERC20(vault).totalSupply() == 0) return 0;\n\n        return IERC20(vault).balanceOf(address(this))\n            .mul(getPricePerFullShare())\n            .div(1e18);\n    }\n\n    function _convert(address _from, address _to, uint256 _amount) internal {\n        require(converter.convert_rate(_from, _to, _amount) > 0, \"!convert_rate\");\n        IERC20(_from).safeTransfer(address(converter), _amount);\n        converter.convert(_from, _to, _amount);\n    }\n\n    // Allow overriding to change the name\n    function getPricePerFullShare() public view virtual returns (uint256) {\n        return IGenericVault(vault).getPricePerFullShare();\n    }\n}\n"
    },
    "contracts/interfaces/GenericVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\ninterface IGenericVault {\n    function token() external view returns (address);\n    function getPricePerFullShare() external view returns (uint256);\n    function deposit(uint256) external;\n    function withdraw(uint256) external;\n    function depositAll() external;\n    function withdrawAll() external;\n}\n"
    },
    "contracts/metavault/mock/MockGenericVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./MockERC20.sol\";\nimport \"../../interfaces/GenericVault.sol\";\n\ncontract MockGenericVault is MockERC20 {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    IERC20 public token;\n\n    uint public min = 9500;\n    uint public constant max = 10000;\n\n    constructor (address _token) public MockERC20(\n        string(abi.encodePacked(\"Generic Vault \", ERC20(_token).name())),\n        string(abi.encodePacked(\"v\", ERC20(_token).symbol())),\n        ERC20(_token).decimals()\n    ) {\n        token = IERC20(_token);\n    }\n\n    function balance() public view returns (uint) {\n        return token.balanceOf(address(this));\n    }\n\n    function available() public view returns (uint) {\n        return token.balanceOf(address(this)).mul(min).div(max);\n    }\n\n    function depositAll() external {\n        deposit(token.balanceOf(msg.sender));\n    }\n\n    function deposit(uint _amount) public {\n        uint _pool = balance();\n        uint _before = token.balanceOf(address(this));\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint _after = token.balanceOf(address(this));\n        _amount = _after.sub(_before);\n        uint shares = 0;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        _mint(msg.sender, shares);\n    }\n\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    function withdraw(uint _shares) public {\n        uint r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n        token.safeTransfer(msg.sender, r);\n    }\n\n    function getPricePerFullShare() public view returns (uint) {\n        return balance().mul(1e18).div(totalSupply());\n    }\n}\n"
    },
    "contracts/metavault/mock/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ncontract MockERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    address private _owner;\n\n    uint internal _totalSupply;\n\n    mapping(address => uint)                   private _balance;\n    mapping(address => mapping(address => uint)) private _allowance;\n\n    modifier _onlyOwner_() {\n        require(msg.sender == _owner, \"ERR_NOT_OWNER\");\n        _;\n    }\n\n    event Approval(address indexed src, address indexed dst, uint amt);\n    event Transfer(address indexed src, address indexed dst, uint amt);\n\n    // Math\n    function add(uint a, uint b) internal pure returns (uint c) {\n        require((c = a + b) >= a);\n    }\n\n    function sub(uint a, uint b) internal pure returns (uint c) {\n        require((c = a - b) <= a);\n    }\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n        _owner = msg.sender;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function _move(address src, address dst, uint amt) internal {\n        require(_balance[src] >= amt, \"!bal\");\n        _balance[src] = sub(_balance[src], amt);\n        _balance[dst] = add(_balance[dst], amt);\n        emit Transfer(src, dst, amt);\n    }\n\n    function _push(address to, uint amt) internal {\n        _move(address(this), to, amt);\n    }\n\n    function _pull(address from, uint amt) internal {\n        _move(from, address(this), amt);\n    }\n\n    function _mint(address dst, uint amt) internal {\n        _balance[dst] = add(_balance[dst], amt);\n        _totalSupply = add(_totalSupply, amt);\n        emit Transfer(address(0), dst, amt);\n    }\n\n    function _burn(address dst, uint amt) internal {\n        _balance[dst] = sub(_balance[dst], amt);\n        _totalSupply = sub(_totalSupply, amt);\n        emit Transfer(dst, address(0), amt);\n    }\n\n    function allowance(address src, address dst) external view returns (uint) {\n        return _allowance[src][dst];\n    }\n\n    function balanceOf(address whom) public view returns (uint) {\n        return _balance[whom];\n    }\n\n    function faucet(uint256 amt) public returns (bool) {\n        _mint(msg.sender, amt);\n        return true;\n    }\n\n    function totalSupply() public view returns (uint) {\n        return _totalSupply;\n    }\n\n    function approve(address dst, uint amt) external returns (bool) {\n        _allowance[msg.sender][dst] = amt;\n        emit Approval(msg.sender, dst, amt);\n        return true;\n    }\n\n    function mint(address dst, uint256 amt) public _onlyOwner_ returns (bool) {\n        _mint(dst, amt);\n        return true;\n    }\n\n    function burn(uint amt) public returns (bool) {\n        require(_balance[msg.sender] >= amt, \"!bal\");\n        _burn(msg.sender, amt);\n        return true;\n    }\n\n    function burnFrom(address src, uint amt) public _onlyOwner_ returns (bool) {\n        require(_balance[src] >= amt, \"!bal\");\n        _burn(src, amt);\n        return true;\n    }\n\n    function transfer(address dst, uint amt) external returns (bool) {\n        _move(msg.sender, dst, amt);\n        return true;\n    }\n\n    function transferFrom(address src, address dst, uint amt) external returns (bool) {\n        require(msg.sender == src || amt <= _allowance[src][msg.sender], \"!spender\");\n        _move(src, dst, amt);\n        if (msg.sender != src && _allowance[src][msg.sender] != uint256(- 1)) {\n            _allowance[src][msg.sender] = sub(_allowance[src][msg.sender], amt);\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\n        }\n        return true;\n    }\n\n    function transferOwnership(address newOwner) external _onlyOwner_ {\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/metavault/mock/MockPickleJar.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../interfaces/PickleJar.sol\";\nimport \"./MockERC20.sol\";\n\ncontract MockPickleJar is MockERC20 {\n    IERC20 public t3crv;\n    IERC20 public lpToken;\n\n    constructor(IERC20 _t3crv) public MockERC20(\"pickling Curve.fi DAI/USDC/USDT\", \"p3Crv\", 18) {\n        t3crv = _t3crv;\n    }\n\n    function balance() public view returns (uint) {\n        return t3crv.balanceOf(address(this));\n    }\n\n    function available() external view returns (uint) {\n        return balance() * 9500 / 10000;\n    }\n\n    function depositAll() external {\n        deposit(t3crv.balanceOf(msg.sender));\n    }\n\n    function deposit(uint _amount) public {\n        t3crv.transferFrom(msg.sender, address(this), _amount);\n        uint256 shares = _amount * 1000000000000000000 / getRatio();\n        _mint(msg.sender, shares);\n    }\n\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    function withdraw(uint _shares) public {\n        uint256 r = _shares * getRatio() / 1000000000000000000;\n        _burn(msg.sender, _shares);\n        t3crv.transfer(msg.sender, r);\n    }\n\n    function getRatio() public pure returns (uint) {\n        return 1010000000000000000; // +1%\n    }\n}\n"
    },
    "contracts/interfaces/PickleJar.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\ninterface PickleJar {\n    function balanceOf(address account) external view returns (uint);\n    function balance() external view returns (uint);\n    function available() external view returns (uint);\n    function depositAll() external;\n    function deposit(uint _amount) external;\n    function withdrawAll() external;\n    function withdraw(uint _shares) external;\n    function getRatio() external view returns (uint);\n}\n"
    },
    "contracts/metavault/strategies/StrategyPickle3Crv.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../IStableSwap3Pool.sol\";\n\nimport \"../../interfaces/PickleJar.sol\";\nimport \"../../interfaces/PickleMasterChef.sol\";\n\nimport \"./BaseStrategy.sol\";\n\ncontract StrategyPickle3Crv is BaseStrategy {\n    address public immutable p3crv;\n\n    // used for pickle -> weth -> [stableForAddLiquidity] -> 3crv route\n    address public immutable pickle;\n\n    // for add_liquidity via curve.fi to get back 3CRV\n    // (set stableForAddLiquidity for the best stable coin used in the route)\n    address public immutable dai;\n    address public immutable usdc;\n    address public immutable usdt;\n\n    PickleJar public immutable pickleJar;\n    PickleMasterChef public pickleMasterChef;\n    uint256 public poolId = 14;\n\n    IStableSwap3Pool public stableSwap3Pool;\n    address public stableForAddLiquidity;\n\n    event SetStableForAddLiquidity(address stableForAddLiquidity);\n    event SetPickleMasterChef(address pickleMasterChef);\n    event SetPoolId(uint256 poolId);\n\n    constructor(\n        string memory _name,\n        address _want,\n        address _p3crv,\n        address _pickle,\n        address _weth,\n        address _dai,\n        address _usdc,\n        address _usdt,\n        address _stableForAddLiquidity,\n        PickleMasterChef _pickleMasterChef,\n        IStableSwap3Pool _stableSwap3Pool,\n        address _controller,\n        address _vaultManager,\n        address _router\n    )\n        public\n        BaseStrategy(_name, _controller, _vaultManager, _want, _weth, _router)\n    {\n        require(_p3crv != address(0), \"!_p3crv\");\n        require(_pickle != address(0), \"!_pickle\");\n        require(_dai != address(0), \"!_dai\");\n        require(_usdc != address(0), \"!_usdc\");\n        require(_usdt != address(0), \"!_usdt\");\n        require(address(_pickleMasterChef) != address(0), \"!_pickleMasterChef\");\n        require(_stableForAddLiquidity != address(0), \"!_stableForAddLiquidity\");\n        require(address(_stableSwap3Pool) != address(0), \"!_stableSwap3Pool\");\n        p3crv = _p3crv;\n        pickle = _pickle;\n        dai = _dai;\n        usdc = _usdc;\n        usdt = _usdt;\n        pickleMasterChef = _pickleMasterChef;\n        stableForAddLiquidity = _stableForAddLiquidity;\n        stableSwap3Pool = _stableSwap3Pool;\n        pickleJar = PickleJar(_p3crv);\n        IERC20(_want).safeApprove(_p3crv, type(uint256).max);\n        IERC20(_p3crv).safeApprove(address(_pickleMasterChef), type(uint256).max);\n        IERC20(_pickle).safeApprove(address(_router), type(uint256).max);\n    }\n\n    function setStableForLiquidity(address _stableForAddLiquidity) external onlyAuthorized {\n        require(_stableForAddLiquidity == dai\n            || _stableForAddLiquidity == usdc\n            || _stableForAddLiquidity == usdt,\n            \"!_stableForAddLiquidity\");\n        stableForAddLiquidity = _stableForAddLiquidity;\n        emit SetStableForAddLiquidity(_stableForAddLiquidity);\n    }\n\n    function setPickleMasterChef(PickleMasterChef _pickleMasterChef) external onlyAuthorized {\n        pickleMasterChef = _pickleMasterChef;\n        IERC20(p3crv).safeApprove(address(_pickleMasterChef), 0);\n        IERC20(p3crv).safeApprove(address(_pickleMasterChef), type(uint256).max);\n        emit SetPickleMasterChef(address(_pickleMasterChef));\n    }\n\n    function setPoolId(uint _poolId) external onlyAuthorized {\n        poolId = _poolId;\n        emit SetPoolId(_poolId);\n    }\n\n    function _deposit() internal override {\n        uint _wantBal = balanceOfWant();\n        if (_wantBal > 0) {\n            // deposit 3crv to pickleJar\n            pickleJar.depositAll();\n        }\n\n        uint _p3crvBal = IERC20(p3crv).balanceOf(address(this));\n        if (_p3crvBal > 0) {\n            // stake p3crv to pickleMasterChef\n            pickleMasterChef.deposit(poolId, _p3crvBal);\n        }\n    }\n\n    function _claimReward() internal {\n        pickleMasterChef.withdraw(poolId, 0);\n    }\n\n    function _withdrawAll() internal override {\n        (uint amount,) = pickleMasterChef.userInfo(poolId, address(this));\n        pickleMasterChef.withdraw(poolId, amount);\n        pickleJar.withdrawAll();\n    }\n\n    // to get back want (3CRV)\n    function _addLiquidity() internal {\n        // 0: DAI, 1: USDC, 2: USDT\n        uint[3] memory amounts;\n        amounts[0] = IERC20(dai).balanceOf(address(this));\n        amounts[1] = IERC20(usdc).balanceOf(address(this));\n        amounts[2] = IERC20(usdt).balanceOf(address(this));\n        // add_liquidity(uint[3] calldata amounts, uint min_mint_amount)\n        stableSwap3Pool.add_liquidity(amounts, 1);\n    }\n\n    function _harvest() internal override {\n        _claimReward();\n        uint256 _remainingWeth = _payHarvestFees(pickle);\n\n        if (_remainingWeth > 0) {\n            _swapTokens(weth, stableForAddLiquidity, _remainingWeth);\n            _addLiquidity();\n\n            if (balanceOfWant() > 0) {\n                _deposit(); // auto re-invest\n            }\n        }\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        // unstake p3crv from pickleMasterChef\n        uint _ratio = pickleJar.getRatio();\n        _amount = _amount.mul(1e18).div(_ratio);\n        (uint _stakedAmount,) = pickleMasterChef.userInfo(poolId, address(this));\n        if (_amount > _stakedAmount) {\n            _amount = _stakedAmount;\n        }\n        uint _before = pickleJar.balanceOf(address(this));\n        pickleMasterChef.withdraw(poolId, _amount);\n        uint _after = pickleJar.balanceOf(address(this));\n        _amount = _after.sub(_before);\n\n        // withdraw 3crv from pickleJar\n        pickleJar.withdraw(_amount);\n    }\n\n    function balanceOfPool() public view override returns (uint) {\n        uint p3crvBal = pickleJar.balanceOf(address(this));\n        (uint amount,) = pickleMasterChef.userInfo(poolId, address(this));\n        return p3crvBal.add(amount).mul(pickleJar.getRatio()).div(1e18);\n    }\n}\n"
    },
    "contracts/interfaces/PickleMasterChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\ninterface PickleMasterChef {\n    function deposit(uint _poolId, uint _amount) external;\n    function withdraw(uint _poolId, uint _amount) external;\n    function pendingPickle(uint _pid, address _user) external view returns (uint);\n    function userInfo(uint _pid, address _user) external view returns (uint amount, uint rewardDebt);\n    function emergencyWithdraw(uint _pid) external;\n}\n"
    },
    "contracts/metavault/StableSwap3PoolConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./IConverter.sol\";\nimport \"./IVaultManager.sol\";\nimport \"./IStableSwap3Pool.sol\";\nimport \"./IStableSwap3PoolOracle.sol\";\n\n/**\n * @title StableSwap3PoolConverter\n * @notice The StableSwap3PoolConverter is used to convert funds on Curve's 3Pool.\n * It is backed by Chainlink's price feeds to be secure against attackers.\n */\ncontract StableSwap3PoolConverter is IConverter {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant ONE_HUNDRED_PERCENT = 10000;\n\n    IVaultManager public immutable vaultManager;\n    IStableSwap3PoolOracle public immutable oracle;\n    IStableSwap3Pool public immutable stableSwap3Pool;\n    IERC20 public immutable token3CRV; // 3Crv\n\n    uint256[3] public PRECISION_MUL = [1, 1e12, 1e12];\n    IERC20[3] public tokens; // DAI, USDC, USDT\n    uint256 public minSlippage;\n\n    mapping(address => bool) public strategies;\n\n    /**\n     * @param _tokenDAI The address of the DAI token\n     * @param _tokenUSDC The address of the USDC token\n     * @param _tokenUSDT The address of the USDT token\n     * @param _token3CRV The address of the 3CRV token\n     * @param _stableSwap3Pool The address of 3Pool\n     * @param _vaultManager The address of the Vault Manager\n     * @param _oracle The address of the StableSwap3PoolOracle\n     */\n    constructor(\n        IERC20 _tokenDAI,\n        IERC20 _tokenUSDC,\n        IERC20 _tokenUSDT,\n        IERC20 _token3CRV,\n        IStableSwap3Pool _stableSwap3Pool,\n        IVaultManager _vaultManager,\n        IStableSwap3PoolOracle _oracle\n    ) public {\n        tokens[0] = _tokenDAI;\n        tokens[1] = _tokenUSDC;\n        tokens[2] = _tokenUSDT;\n        token3CRV = _token3CRV;\n        stableSwap3Pool = _stableSwap3Pool;\n        tokens[0].safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        tokens[1].safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        tokens[2].safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        _token3CRV.safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        vaultManager = _vaultManager;\n        oracle = _oracle;\n        minSlippage = 100;\n    }\n\n    /**\n     * @notice Called by Governance to enable or disable a strategy to use the converter\n     * @param _strategy The address of the strategy\n     * @param _status The bool flag allowing or disallowing use of the converter by the strategy\n     */\n    function setStrategy(address _strategy, bool _status) external override onlyGovernance {\n        strategies[_strategy] = _status;\n    }\n\n    /**\n     * @notice Called by the strategist to set the slippage allowed on the minimum tokens received\n     * @param _slippage The slippage percentage\n     */\n    function setMinSlippage(uint256 _slippage) external onlyStrategist {\n        require(_slippage < ONE_HUNDRED_PERCENT, \"!_slippage\");\n        minSlippage = _slippage;\n    }\n\n    /**\n     * @notice Called by Governance to approve a token address to be spent by an address\n     * @param _token The address of the token\n     * @param _spender The address of the spender\n     * @param _amount The amount to spend\n     */\n    function approveForSpender(\n        IERC20 _token,\n        address _spender,\n        uint256 _amount\n    ) external onlyGovernance {\n        _token.safeApprove(_spender, _amount);\n    }\n\n    /**\n     * @notice Returns the address of the 3CRV token\n     */\n    function token() external view override returns (address) {\n        return address(token3CRV);\n    }\n\n    /**\n     * @notice Returns the expected amount of tokens for a given amount by querying\n     * the latest data from Chainlink\n     * @param _inputAmount The input amount of tokens that are being converted\n     */\n    function getExpected(uint256 _inputAmount) public view returns (uint256 _min, uint256 _max) {\n        ( _min, _max ) = oracle.getPrices();\n        uint256 _eth = oracle.getEthereumPrice();\n        _min = _inputAmount.mul(_eth).mul(_min).div(1e18).div(1e18);\n        uint256 _slippage = minSlippage;\n        if (_slippage > 0) {\n            _slippage = _min.mul(_slippage).div(ONE_HUNDRED_PERCENT);\n            _min = _min.sub(_slippage);\n        }\n        _max = _inputAmount.mul(_eth).mul(_max).div(1e18).div(1e18);\n    }\n\n    /**\n     * @notice Converts the amount of input tokens to output tokens\n     * @param _input The address of the token being converted\n     * @param _output The address of the token to be converted to\n     * @param _inputAmount The input amount of tokens that are being converted\n     */\n    function convert(\n        address _input,\n        address _output,\n        uint256 _inputAmount\n    ) external override onlyAuthorized returns (uint256 _outputAmount) {\n        if (_output == address(token3CRV)) { // convert to 3CRV\n            uint256[3] memory amounts;\n            for (uint8 i = 0; i < 3; i++) {\n                if (_input == address(tokens[i])) {\n                    ( uint256 _min, uint256 _max ) = getExpected(_inputAmount.mul(PRECISION_MUL[i]));\n                    amounts[i] = _inputAmount;\n                    uint256 _before = token3CRV.balanceOf(address(this));\n                    stableSwap3Pool.add_liquidity(amounts, _min);\n                    uint256 _after = token3CRV.balanceOf(address(this));\n                    _outputAmount = _after.sub(_before);\n                    require(_outputAmount <= _max, \">_max\");\n                    token3CRV.safeTransfer(msg.sender, _outputAmount);\n                    return _outputAmount;\n                }\n            }\n        } else if (_input == address(token3CRV)) { // convert from 3CRV\n            ( uint256 _min, uint256 _max ) = getExpected(_inputAmount);\n            for (uint8 i = 0; i < 3; i++) {\n                if (_output == address(tokens[i])) {\n                    uint256 _before = tokens[i].balanceOf(address(this));\n                    stableSwap3Pool.remove_liquidity_one_coin(_inputAmount, i, _min.div(PRECISION_MUL[i]));\n                    uint256 _after = tokens[i].balanceOf(address(this));\n                    _outputAmount = _after.sub(_before);\n                    require(_outputAmount <= _max, \">_max\");\n                    tokens[i].safeTransfer(msg.sender, _outputAmount);\n                    return _outputAmount;\n                }\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Checks the amount of input tokens to output tokens\n     * @param _input The address of the token being converted\n     * @param _output The address of the token to be converted to\n     * @param _inputAmount The input amount of tokens that are being converted\n     */\n    function convert_rate(\n        address _input,\n        address _output,\n        uint256 _inputAmount\n    ) external override view returns (uint256) {\n        if (_output == address(token3CRV)) { // convert to 3CRV\n            uint256[3] memory amounts;\n            for (uint8 i = 0; i < 3; i++) {\n                if (_input == address(tokens[i])) {\n                    amounts[i] = _inputAmount;\n                    return stableSwap3Pool.calc_token_amount(amounts, true);\n                }\n            }\n        } else if (_input == address(token3CRV)) { // convert from 3CRV\n            for (uint8 i = 0; i < 3; i++) {\n                if (_output == address(tokens[i])) {\n                    // @dev this is for UI reference only, the actual share price\n                    // (stable/CRV) will be re-calculated on-chain when we do convert()\n                    return stableSwap3Pool.calc_withdraw_one_coin(_inputAmount, i);\n                }\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Converts stables of the 3Pool to 3CRV\n     * @dev 0: DAI, 1: USDC, 2: USDT\n     * @param amounts Array of token amounts\n     */\n    function convert_stables(\n        uint256[3] calldata amounts\n    ) external override onlyAuthorized returns (uint256 _shareAmount) {\n        uint256 _sum;\n        for (uint8 i; i < 3; i++) {\n            _sum = _sum.add(amounts[i].mul(PRECISION_MUL[i]));\n        }\n        ( uint256 _min, uint256 _max ) = getExpected(_sum);\n        uint256 _before = token3CRV.balanceOf(address(this));\n        stableSwap3Pool.add_liquidity(amounts, _min);\n        uint256 _after = token3CRV.balanceOf(address(this));\n        _shareAmount = _after.sub(_before);\n        require(_shareAmount <= _max, \">_max\");\n        token3CRV.safeTransfer(msg.sender, _shareAmount);\n    }\n\n    /**\n     * @notice Checks the amount of 3CRV given for the amounts\n     * @dev 0: DAI, 1: USDC, 2: USDT\n     * @param amounts Array of token amounts\n     * @param deposit Flag for depositing LP tokens\n     */\n    function calc_token_amount(\n        uint256[3] calldata amounts,\n        bool deposit\n    ) external override view returns (uint256 _shareAmount) {\n        _shareAmount = stableSwap3Pool.calc_token_amount(amounts, deposit);\n    }\n\n    /**\n     * @notice Checks the amount of an output token given for 3CRV\n     * @param _shares The amount of 3CRV\n     * @param _output The address of the output token\n     */\n    function calc_token_amount_withdraw(\n        uint256 _shares,\n        address _output\n    ) external override view returns (uint256) {\n        for (uint8 i = 0; i < 3; i++) {\n            if (_output == address(tokens[i])) {\n                return stableSwap3Pool.calc_withdraw_one_coin(_shares, i);\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Allows Governance to withdraw tokens from the converter\n     * @dev This contract should never have any tokens in it at the end of a transaction\n     * @param _token The address of the token\n     * @param _amount The amount to withdraw\n     * @param _to The address to receive the tokens\n     */\n    function governanceRecoverUnsupported(\n        IERC20 _token,\n        uint256 _amount,\n        address _to\n    ) external onlyGovernance {\n        _token.safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @dev Throws if not called by a vault, controller, strategy, or governance\n     */\n    modifier onlyAuthorized() {\n        require(vaultManager.vaults(msg.sender)\n            || vaultManager.controllers(msg.sender)\n            || strategies[msg.sender]\n            || msg.sender == vaultManager.governance(),\n            \"!authorized\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Throws if not called by a controller or governance\n     */\n    modifier onlyGovernance() {\n        require(vaultManager.controllers(msg.sender)\n            || msg.sender == vaultManager.governance(), \"!governance\");\n        _;\n    }\n\n    /**\n     * @dev Throws if not called by the strategist\n     */\n    modifier onlyStrategist {\n        require(msg.sender == vaultManager.strategist(), \"!strategist\");\n        _;\n    }\n}\n"
    },
    "contracts/metavault/IStableSwap3PoolOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\ninterface IStableSwap3PoolOracle {\n    function getEthereumPrice() external view returns (uint256);\n    function getPrices() external view returns (uint256, uint256);\n    function getSafeAnswer(address) external view returns (uint256);\n}\n"
    },
    "contracts/metavault/StableSwap3PoolOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./IStableSwap3PoolOracle.sol\";\nimport \"../interfaces/Chainlink.sol\";\n\ncontract StableSwap3PoolOracle is IStableSwap3PoolOracle {\n    using SafeMath for uint256;\n\n    uint256 public constant MAX_ROUND_TIME = 1 hours;\n    uint256 public constant MAX_STALE_ANSWER = 24 hours;\n    uint256 public constant ETH_USD_MUL = 1e10; // ETH-USD feed is to 8 decimals\n\n    address public immutable ethUsd;\n    address[3] public feeds;\n\n    constructor(\n        address _feedETHUSD,\n        address _feedDAIETH,\n        address _feedUSDCETH,\n        address _feedUSDTETH\n    )\n        public\n    {\n        ethUsd = _feedETHUSD;\n        feeds[0] = _feedDAIETH;\n        feeds[1] = _feedUSDCETH;\n        feeds[2] = _feedUSDTETH;\n    }\n\n    /**\n     * @notice Retrieves the current price of ETH/USD as provided by Chainlink\n     * @dev Reverts if the answer from Chainlink is not safe\n     */\n    function getEthereumPrice() external view override returns (uint256 _price) {\n        _price = getSafeAnswer(ethUsd);\n        require(_price > 0, \"!getEthereumPrice\");\n        _price = _price.mul(ETH_USD_MUL);\n\n    }\n\n    /**\n     * @notice Retrieves the minimum price of the 3pool tokens as provided by Chainlink\n     * @dev Reverts if none of the Chainlink nodes are safe\n     */\n    function getPrices() external view override returns (uint256 _minPrice, uint256 _maxPrice) {\n        for (uint8 i = 0; i < 3; i++) {\n            // get the safe answer from Chainlink\n            uint256 _answer = getSafeAnswer(feeds[i]);\n\n            // store the first iteration regardless (handle that later if 0)\n            // otherwise,check that _answer is greater than 0 and only store it if less\n            // than the previously observed price\n            if (i == 0) {\n                _minPrice = _answer;\n                _maxPrice = _answer;\n            } else if (_answer > 0 && _answer < _minPrice) {\n                _minPrice = _answer;\n            } else if (_answer > 0 && _answer > _maxPrice) {\n                _maxPrice = _answer;\n            }\n        }\n\n        // if we couldn't get a valid price from any of the Chainlink feeds,\n        // revert because nothing is safe\n        require(_minPrice > 0 && _maxPrice > 0, \"!getPrices\");\n    }\n\n    /**\n     * @notice Get and check the answer provided by Chainlink\n     * @param _feed The address of the Chainlink price feed\n     */\n    function getSafeAnswer(address _feed) public view override returns (uint256) {\n        (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        ) = AggregatorV3Interface(_feed).latestRoundData();\n\n        // latest round is carried over from previous round\n        if (answeredInRound < roundId) {\n            return 0;\n        }\n\n        // latest answer is stale\n        // solhint-disable-next-line not-rely-on-time\n        if (updatedAt < block.timestamp.sub(MAX_STALE_ANSWER)) {\n            return 0;\n        }\n\n        // round has taken too long to collect answers\n        if (updatedAt.sub(startedAt) > MAX_ROUND_TIME) {\n            return 0;\n        }\n\n        // Chainlink already rejects answers outside of a range (like what would cause\n        // a negative answer)\n        return uint256(answer);\n    }\n}\n"
    },
    "contracts/interfaces/Chainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\ninterface AggregatorInterface {\n      function latestAnswer() external view returns (int256);\n      function latestTimestamp() external view returns (uint256);\n      function latestRound() external view returns (uint256);\n      function getAnswer(uint256 roundId) external view returns (int256);\n      function getTimestamp(uint256 roundId) external view returns (uint256);\n}\n\ninterface AggregatorV3Interface {\n\n      function decimals() external view returns (uint8);\n      function description() external view returns (string memory);\n      function version() external view returns (uint256);\n\n      // getRoundData and latestRoundData should both raise \"No data present\"\n      // if they do not have data to report, instead of returning unset values\n      // which could be misinterpreted as actual reported values.\n      function getRoundData(uint80 _roundId)\n            external\n            view\n            returns (\n                  uint80 roundId,\n                  int256 answer,\n                  uint256 startedAt,\n                  uint256 updatedAt,\n                  uint80 answeredInRound\n            );\n      function latestRoundData()\n            external\n            view\n            returns (\n                  uint80 roundId,\n                  int256 answer,\n                  uint256 startedAt,\n                  uint256 updatedAt,\n                  uint80 answeredInRound\n            );\n}\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface\n{\n}\n"
    },
    "contracts/metavault/mock/MockV3Aggregatgor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../../interfaces/Chainlink.sol\";\n\n/**\n * @title MockV3Aggregator\n * @notice Based on the FluxAggregator contract\n * @notice Use this contract when you need to test\n * other contract's ability to read data from an\n * aggregator contract, but how the aggregator got\n * its answer is unimportant\n */\ncontract MockV3Aggregator is AggregatorV2V3Interface {\n  uint256 constant public override version = 0;\n\n  uint8 public override decimals;\n  int256 public override latestAnswer;\n  uint256 public override latestTimestamp;\n  uint256 public override latestRound;\n\n  mapping(uint256 => int256) public override getAnswer;\n  mapping(uint256 => uint256) public override getTimestamp;\n  mapping(uint256 => uint256) private getStartedAt;\n\n  constructor(\n    uint8 _decimals,\n    int256 _initialAnswer\n  ) public {\n    decimals = _decimals;\n    updateAnswer(_initialAnswer);\n  }\n\n  function updateAnswer(\n    int256 _answer\n  ) public {\n    latestAnswer = _answer;\n    latestTimestamp = block.timestamp;\n    latestRound++;\n    getAnswer[latestRound] = _answer;\n    getTimestamp[latestRound] = block.timestamp;\n    getStartedAt[latestRound] = block.timestamp;\n  }\n\n  function updateRoundData(\n    uint80 _roundId,\n    int256 _answer,\n    uint256 _timestamp,\n    uint256 _startedAt\n  ) public {\n    latestRound = _roundId;\n    latestAnswer = _answer;\n    latestTimestamp = _timestamp;\n    getAnswer[latestRound] = _answer;\n    getTimestamp[latestRound] = _timestamp;\n    getStartedAt[latestRound] = _startedAt;\n  }\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    return (\n      _roundId,\n      getAnswer[_roundId],\n      getStartedAt[_roundId],\n      getTimestamp[_roundId],\n      _roundId\n    );\n  }\n\n  function latestRoundData()\n    external\n    view\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    return (\n      uint80(latestRound),\n      getAnswer[latestRound],\n      getStartedAt[latestRound],\n      getTimestamp[latestRound],\n      uint80(latestRound)\n    );\n  }\n\n  function description()\n    external\n    view\n    override\n    returns (string memory)\n  {\n    return \"v0.6/tests/MockV3Aggregator.sol\";\n  }\n}\n"
    },
    "contracts/metavault/strategies/StrategydYdXSoloMargin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"../../interfaces/dYdXSoloMargin.sol\";\nimport \"../IConverter.sol\";\nimport \"./BaseStrategy.sol\";\n\ncontract StrategydYdXSoloMargin is BaseStrategy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public dYdX;\n    uint256 marketId;\n    IConverter public converter;\n\n    /**\n       * @param _dYdX The address of the dYdX Solo Margin contract\n       * @param _marketId The dYdX Solo Margin Market ID: https://docs.dydx.exchange/#solo-markets\n       * @param _converter The address of the converter\n       * @param _controller The address of the controller\n       * @param _vaultManager The address of the vaultManager\n       * @param _weth The address of WETH\n       * @param _router The address of the router for swapping tokens\n       */\n    constructor(\n        address _dYdX,\n        uint256 _marketId,\n        address _converter,\n        address _controller,\n        address _vaultManager,\n        address _weth,\n        address _router\n    )\n    public\n    BaseStrategy(\n        string(abi.encodePacked(\"dYdX SoloMargin: \", ERC20(ISoloMargin(_dYdX).getMarketTokenAddress(_marketId)).symbol())),\n        _controller,\n        _vaultManager,\n        ISoloMargin(_dYdX).getMarketTokenAddress(_marketId),\n        _weth,\n        _router\n    )\n    {\n        require(_dYdX != address(0), \"!_dYdX\");\n        require(_converter != address(0), \"!_converter\");\n        dYdX = _dYdX;\n        marketId = _marketId;\n        converter = IConverter(_converter);\n        IERC20(ISoloMargin(_dYdX).getMarketTokenAddress(_marketId)).safeApprove(_dYdX, type(uint256).max);\n    }\n\n    function _deposit() internal override {\n        uint256 _amount = balanceOfWant();\n        if (_amount > 0) {\n            Account.Info[] memory accounts = new Account.Info[](1);\n            accounts[0] = Account.Info({\n                owner: address(this),\n                number: 0 // Should be MARGIN\n            });\n\n            Actions.ActionArgs[] memory actions = new Actions.ActionArgs[](1);\n            actions[0] = Actions.ActionArgs({\n                actionType: Actions.ActionType.Deposit,\n                accountId: 0,\n                amount: Types.AssetAmount({\n                    sign: true,\n                    denomination: Types.AssetDenomination.Wei,\n                    ref: Types.AssetReference.Delta,\n                    value: _amount\n                }),\n                primaryMarketId: marketId,\n                secondaryMarketId: 0,\n                otherAddress: address(this),\n                otherAccountId: 0,\n                data: \"\"\n            });\n\n            ISoloMargin(dYdX).operate(accounts, actions);\n        }\n    }\n\n    function _harvest() internal override {\n        // Harvest is not necessary in this strategy\n        return;\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        Account.Info[] memory accounts = new Account.Info[](1);\n        accounts[0] = Account.Info({\n            owner: address(this),\n            number: 0 // Should be MARGIN\n        });\n\n        Actions.ActionArgs[] memory actions = new Actions.ActionArgs[](1);\n        actions[0] = Actions.ActionArgs({\n            actionType: Actions.ActionType.Withdraw,\n            accountId: 0,\n            amount: Types.AssetAmount({\n                sign: false,\n                denomination: Types.AssetDenomination.Wei,\n                ref: Types.AssetReference.Delta,\n                value: _amount\n            }),\n            primaryMarketId: marketId,\n            secondaryMarketId: 0,\n            otherAddress: address(this),\n            otherAccountId: 0,\n            data: \"\"\n        });\n\n        ISoloMargin(dYdX).operate(accounts, actions);\n\n        _amount = balanceOfWant();\n        if (_amount > 0) {\n            _convert(want, _vaultWant(), _amount);\n        }\n    }\n\n    function _withdrawAll() internal override {\n        uint256 amount = balanceOfPool();\n        if (amount > 0) {\n            _withdraw(amount);\n        }\n    }\n\n    function balanceOfPool() public view override returns (uint256) {\n        Account.Info memory account = Account.Info({\n            owner: address(this),\n            number: 0 // Should be MARGIN\n        });\n        Types.Wei memory balance = ISoloMargin(dYdX).getAccountWei(account, marketId);\n        if (balance.sign) {\n            return balance.value;\n        }\n        return 0;\n    }\n\n    function _convert(address _from, address _to, uint256 _amount) internal {\n        require(converter.convert_rate(_from, _to, _amount) > 0, \"!convert_rate\");\n        IERC20(_from).safeTransfer(address(converter), _amount);\n        converter.convert(_from, _to, _amount);\n    }\n}\n"
    },
    "contracts/interfaces/dYdXSoloMargin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\npragma experimental ABIEncoderV2;\n\nlibrary Account {\n    enum Status {\n        Normal,\n        Liquid,\n        Vapor\n    }\n\n    struct Info {\n        address owner;  // The address that owns the account\n        uint256 number; // A nonce that allows a single address to control many accounts\n    }\n\n    function equals(\n        Info memory a,\n        Info memory b\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        return a.owner == b.owner && a.number == b.number;\n    }\n}\n\nlibrary Types {\n    enum AssetDenomination {\n        Wei // the amount is denominated in wei\n    }\n\n    struct Wei {\n        bool sign; // true if positive\n        uint256 value;\n    }\n\n    enum AssetReference {\n        Delta // the amount is given as a delta from the current value\n    }\n\n    struct AssetAmount {\n        bool sign; // true if positive\n        AssetDenomination denomination;\n        AssetReference ref;\n        uint256 value;\n    }\n}\n\nlibrary Actions {\n    enum ActionType {\n        Deposit, // supply tokens\n        Withdraw // borrow tokens\n    }\n\n    enum AccountLayout {\n        OnePrimary,\n        TwoPrimary,\n        PrimaryAndSecondary\n    }\n\n    enum MarketLayout {\n        ZeroMarkets,\n        OneMarket,\n        TwoMarkets\n    }\n\n    struct ActionArgs {\n        ActionType actionType;\n        uint256 accountId;\n        Types.AssetAmount amount;\n        uint256 primaryMarketId;\n        uint256 secondaryMarketId;\n        address otherAddress;\n        uint256 otherAccountId;\n        bytes data;\n    }\n\n    struct DepositArgs {\n        Types.AssetAmount amount;\n        Account.Info account;\n        uint256 market;\n        address from;\n    }\n\n    struct WithdrawArgs {\n        Types.AssetAmount amount;\n        Account.Info account;\n        uint256 market;\n        address to;\n    }\n\n    function parseDepositArgs(\n        Account.Info[] memory accounts,\n        ActionArgs memory args\n    )\n        internal\n        pure\n        returns (DepositArgs memory)\n    {\n        assert(args.actionType == ActionType.Deposit);\n        return DepositArgs({\n            amount: args.amount,\n            account: accounts[args.accountId],\n            market: args.primaryMarketId,\n            from: args.otherAddress\n        });\n    }\n\n    function parseWithdrawArgs(\n        Account.Info[] memory accounts,\n        ActionArgs memory args\n    )\n        internal\n        pure\n        returns (WithdrawArgs memory)\n    {\n        assert(args.actionType == ActionType.Withdraw);\n        return WithdrawArgs({\n            amount: args.amount,\n            account: accounts[args.accountId],\n            market: args.primaryMarketId,\n            to: args.otherAddress\n        });\n    }\n}\n\ninterface ISoloMargin {\n    function operate(Account.Info[] memory accounts, Actions.ActionArgs[] memory actions) external;\n    function getMarketTokenAddress(uint256 marketId) external view returns (address);\n    function getAccountWei(Account.Info memory account, uint256 marketId) external view returns (Types.Wei memory);\n}\n"
    },
    "contracts/metavault/mock/MockdYdXSoloMargin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../../interfaces/dYdXSoloMargin.sol\";\n\ncontract MockdYdXSoloMargin is ISoloMargin {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n\n    // Store balances as (Account => (MarketID => balance))\n    mapping(address => mapping(uint256 => uint128)) balances;\n\n    // Mapping of tokens as (MarketID => token)\n    mapping(uint256 => address) tokens;\n\n    constructor (uint256[] memory _marketIds, address[] memory _addresses) public {\n        require(_marketIds.length == _addresses.length, \"marketIds.length != addresses.length\");\n        for (uint256 i = 0; i < _marketIds.length; i++) {\n            tokens[_marketIds[i]] = _addresses[i];\n        }\n    }\n\n    function operate(Account.Info[] memory accounts, Actions.ActionArgs[] memory actions) public override {\n        _verifyInputs(accounts, actions);\n\n        _runActions(\n            accounts,\n            actions\n        );\n    }\n\n    function _verifyInputs(\n        Account.Info[] memory accounts,\n        Actions.ActionArgs[] memory actions\n    ) private pure {\n        require(actions.length != 0, \"Cannot have zero actions\");\n        require(accounts.length != 0, \"Cannot have zero accounts\");\n\n        for (uint256 a = 0; a < accounts.length; a++) {\n            for (uint256 b = a + 1; b < accounts.length; b++) {\n                require(!Account.equals(accounts[a], accounts[b]), \"Cannot duplicate accounts\");\n            }\n        }\n    }\n\n    function _runActions(\n        Account.Info[] memory accounts,\n        Actions.ActionArgs[] memory actions\n    ) private {\n        for (uint256 i = 0; i < actions.length; i++) {\n            Actions.ActionArgs memory action = actions[i];\n            Actions.ActionType actionType = action.actionType;\n\n            if (actionType == Actions.ActionType.Deposit) {\n                _deposit(Actions.parseDepositArgs(accounts, action));\n            } else if (actionType == Actions.ActionType.Withdraw) {\n                _withdraw(Actions.parseWithdrawArgs(accounts, action));\n            }\n        }\n    }\n\n    function _deposit(\n        Actions.DepositArgs memory args\n    )\n        private\n    {\n        require(\n            args.from == msg.sender || args.from == args.account.owner,\n            \"Invalid deposit source\"\n        );\n\n        // We'll not implement all cases in this mock, for simplicity\n        require(args.amount.denomination == Types.AssetDenomination.Wei, \"!Types.AssetDenomination.Wei\");\n        IERC20(tokens[args.market]).safeTransferFrom(args.from, address(this), args.amount.value);\n\n        uint128 newBalance = to128(SafeMath.add(balances[args.account.owner][args.market], args.amount.value));\n        balances[args.account.owner][args.market] = newBalance;\n    }\n\n    function _withdraw(\n        Actions.WithdrawArgs memory args\n    )\n        private\n    {\n        require(\n            msg.sender == args.account.owner,\n            \"Not valid operator\"\n        );\n        require(args.amount.value <= balances[args.account.owner][args.market], \"!balance\");\n        require(!args.amount.sign, \"should receive negative amount\");\n        IERC20(tokens[args.market]).safeTransfer(args.to, args.amount.value);\n\n        uint128 newBalance = to128(SafeMath.sub(balances[args.account.owner][args.market], args.amount.value));\n        balances[args.account.owner][args.market] = newBalance;\n    }\n\n    function getMarketTokenAddress(uint256 marketId) external override view returns (address) {\n        return tokens[marketId];\n    }\n\n    function getAccountWei(Account.Info memory account, uint256 marketId)\n        external\n        override\n        view\n        returns (Types.Wei memory)\n    {\n        Types.Wei memory balance = Types.Wei({\n            sign: true,\n            value: balances[account.owner][marketId]\n        });\n        return balance;\n    }\n\n    function to128(\n        uint256 number\n    )\n        internal\n        pure\n        returns (uint128)\n    {\n        uint128 result = uint128(number);\n        require(result == number, \"Unsafe cast to uint128\");\n        return result;\n    }\n}\n"
    },
    "contracts/metavault/mock/MockzpaToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../interfaces/Stabilize.sol\";\n\ncontract MockzpaToken is ERC20, IZPAToken {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    address constant DEAD = 0x000000000000000000000000000000000000dEaD;\n    uint256 constant divisionFactor = 100000;\n\n    address public override underlyingAsset;\n    uint256 public override initialFee = 1000; // 1000 = 1%, 100000 = 100%, max fee restricted in contract is 10%\n    uint256 public override endFee = 100; // 100 = 0.1%\n    uint256 public override feeDuration = 604800; // The amount of seconds it takes from the initial to end fee\n\n    // Info of each user.\n    struct UserInfo {\n        uint256 depositTime; // The time the user made a deposit, every deposit resets the time\n    }\n\n    mapping(address => UserInfo) private userInfo;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _underlyingAsset\n    )\n        public\n        ERC20(_name, _symbol)\n    {\n        underlyingAsset = _underlyingAsset;\n    }\n\n    function deposit(uint256 _amount) external override {\n        uint256 _toMint = _amount.mul(1e18).div(pricePerToken());\n        IERC20(underlyingAsset).safeTransferFrom(msg.sender, address(this), _amount);\n        _mint(msg.sender, _toMint);\n        userInfo[_msgSender()].depositTime = block.timestamp; // Update the deposit time\n    }\n\n    function redeem(uint256 _amount) external override {\n        uint256 _underlyingAmount = _amount.mul(pricePerToken()).div(1e18);\n        _burn(msg.sender, _amount);\n\n        // Pay fee upon withdrawing\n        if (userInfo[_msgSender()].depositTime == 0) {\n            // The user has never deposited here\n            userInfo[_msgSender()].depositTime = block.timestamp; // Give them the max fee\n        }\n\n        uint256 feeSubtraction = initialFee.sub(endFee).mul(block.timestamp.sub(userInfo[_msgSender()].depositTime)).div(feeDuration);\n        if (feeSubtraction > initialFee.sub(endFee)) {\n            // Cannot reduce fee more than this\n            feeSubtraction = initialFee.sub(endFee);\n        }\n        uint256 fee = initialFee.sub(feeSubtraction);\n        fee = _underlyingAmount.mul(fee).div(divisionFactor);\n        _underlyingAmount = _underlyingAmount.sub(fee);\n\n        // Now withdraw this amount to the user and send fee to treasury\n        IERC20(underlyingAsset).safeTransfer(msg.sender, _underlyingAmount);\n        IERC20(underlyingAsset).safeTransfer(DEAD, fee);\n    }\n\n    function pricePerToken() public view override returns (uint256) {\n        return 2e18;\n    }\n}\n"
    },
    "contracts/interfaces/Stabilize.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\ninterface IZPAToken {\n    function deposit(uint256) external;\n    function redeem(uint256) external;\n    function underlyingAsset() external view returns (address);\n    function pricePerToken() external view returns (uint256);\n\n    function initialFee() external view returns (uint256);\n    function endFee() external view returns (uint256);\n    function feeDuration() external view returns (uint256);\n}\n\ninterface IZPAPool {\n    function deposit(uint256, uint256) external;\n    function withdraw(uint256, uint256) external;\n    function exit(uint256, uint256) external;\n    function getReward(uint256) external;\n    function rewardEarned(uint256, address) external view returns (uint256);\n    function poolTokenAddress(uint256) external view returns (address);\n    function poolBalance(uint256, address) external view returns (uint256);\n}\n"
    },
    "contracts/metavault/strategies/StrategyStabilize.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../../interfaces/Stabilize.sol\";\nimport \"../IConverter.sol\";\nimport \"./BaseStrategy.sol\";\n\ncontract StrategyStabilize is BaseStrategy {\n    address public immutable zpaToken;\n    address public immutable pool;\n    address public immutable STBZ;\n    uint256 public immutable poolId;\n    IConverter public converter;\n\n    uint256 private depositTime; // The time the strategy made a deposit into zpa-Token, every deposit resets the time\n    uint256 private constant DIVISION_FACTOR = 100000;\n    uint256 private constant INITIAL_FEE = 1000; // 1000 = 1%, 100000 = 100%, max fee restricted in contract is 10%\n    uint256 private constant END_FEE = 100; // 100 = 0.1%\n    uint256 private constant FEE_DURATION = 604800; // The amount of seconds it takes from the initial to end fee\n\n    constructor(\n        string memory _name,\n        address _underlying,\n        address _zpaToken,\n        address _pool,\n        uint256 _poolId,\n        address _STBZ,\n        address _converter,\n        address _controller,\n        address _vaultManager,\n        address _weth,\n        address _router\n    )\n        public\n        BaseStrategy(_name, _controller, _vaultManager, _underlying, _weth, _router)\n    {\n        require(_zpaToken != address(0), \"!_zpaToken\");\n        require(_pool != address(0), \"!_pool\");\n        require(_STBZ != address(0), \"!_STBZ\");\n        require(_converter != address(0), \"!_converter\");\n        zpaToken = _zpaToken;\n        pool = _pool;\n        poolId = _poolId;\n        STBZ = _STBZ;\n        converter = IConverter(_converter);\n        IERC20(_STBZ).safeApprove(address(_router), type(uint256).max);\n        IERC20(_underlying).safeApprove(address(_converter), type(uint256).max);\n        IERC20(_underlying).safeApprove(_zpaToken, type(uint256).max);\n        IERC20(_zpaToken).safeApprove(_pool, type(uint256).max);\n    }\n\n    function balanceOfPool() public view override returns (uint256) {\n        IZPAToken _zpaToken = IZPAToken(zpaToken);\n        uint256 zpaBalance = balanceOfzpaToken()\n                            .mul(_zpaToken.pricePerToken())\n                            .div(1e18);\n        return (IZPAPool(pool).poolBalance(poolId, address(this)))\n            .mul(_zpaToken.pricePerToken())\n            .div(1e18)\n            .add(zpaBalance).sub(calculateZPATokenWithdrawFee(zpaBalance));\n    }\n\n    function balanceOfzpaToken() public view returns (uint256) {\n        return IERC20(zpaToken).balanceOf(address(this));\n    }\n\n    function calculateZPATokenWithdrawFee(uint256 amount) public view returns (uint256) {\n        uint256 _depositTime = depositTime;\n        if (_depositTime == 0) {\n            // Never deposited\n            _depositTime = block.timestamp; // Give the max fee\n        }\n\n        uint256 feeSubtraction = INITIAL_FEE.sub(END_FEE).mul(block.timestamp.sub(_depositTime)).div(FEE_DURATION);\n        if (feeSubtraction > INITIAL_FEE.sub(END_FEE)) {\n            // Cannot reduce fee more than this\n            feeSubtraction = INITIAL_FEE.sub(END_FEE);\n        }\n        uint256 fee = INITIAL_FEE.sub(feeSubtraction);\n        return amount.mul(fee).div(DIVISION_FACTOR);\n    }\n\n    function _deposit() internal override {\n        uint256 amount = balanceOfWant();\n        if (amount > 0) {\n            depositTime = block.timestamp;\n            IZPAToken(zpaToken).deposit(amount);\n        }\n        amount = balanceOfzpaToken();\n        if (amount > 0) {\n            IZPAPool(pool).deposit(poolId, amount);\n        }\n    }\n\n    function _harvest() internal override {\n        IZPAPool(pool).getReward(poolId);\n        uint256 remainingWeth = _payHarvestFees(STBZ);\n\n        if (remainingWeth > 0) {\n            _swapTokens(weth, want, remainingWeth);\n\n            if (balanceOfWant() > 0) {\n                _deposit();\n            }\n        }\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        _amount = _amount.mul(1e18).div(IZPAToken(zpaToken).pricePerToken());\n        uint256 _before = balanceOfzpaToken();\n        IZPAPool(pool).withdraw(poolId, _amount);\n        uint256 _after = balanceOfzpaToken();\n        _amount = _after.sub(_before);\n        IZPAToken(zpaToken).redeem(_amount);\n        _amount = balanceOfWant();\n        if (_amount > 0) {\n            _convert(want, _vaultWant(), _amount);\n        }\n    }\n\n    function _withdrawAll() internal override {\n        uint256 amount = IZPAPool(pool).poolBalance(poolId, address(this));\n        IZPAPool(pool).exit(poolId, amount);\n\n        amount = balanceOfzpaToken();\n        if (amount > 0) {\n            IZPAToken(zpaToken).redeem(amount);\n            amount = balanceOfWant();\n            _convert(want, _vaultWant(), amount);\n        }\n    }\n\n    function _convert(address _from, address _to, uint256 _amount) internal {\n        require(converter.convert_rate(_from, _to, _amount) > 0, \"!convert_rate\");\n        IERC20(_from).safeTransfer(address(converter), _amount);\n        converter.convert(_from, _to, _amount);\n    }\n}\n"
    },
    "contracts/metavault/mock/MockStabilizePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../interfaces/Stabilize.sol\";\n\ncontract MockStabilizePool is IZPAPool {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IERC20 public lpToken;\n    IERC20 public rewardToken;\n    uint256 public rewardRate;\n\n    struct UserInfo {\n        uint256 amount;\n        uint256 rewardDebt;\n        uint256 unclaimedReward;\n    }\n\n    mapping(uint256 => mapping(address => UserInfo)) private userInfo;\n    mapping(uint256 => address) public override poolTokenAddress;\n\n    constructor(\n        address _lpToken,\n        address _rewardToken,\n        uint256 _rewardRate\n    ) public {\n        lpToken = IERC20(_lpToken);\n        rewardToken = IERC20(_rewardToken);\n        rewardRate = _rewardRate;\n    }\n\n    function deposit(uint256 _pid, uint256 _amount) external override {\n        userInfo[_pid][msg.sender].amount = userInfo[_pid][msg.sender].amount.add(_amount);\n        lpToken.safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    function withdraw(uint256 _pid, uint256 _amount) public override {\n        userInfo[_pid][msg.sender].amount = userInfo[_pid][msg.sender].amount.sub(_amount);\n        lpToken.safeTransfer(msg.sender, _amount);\n    }\n\n    function exit(uint256 _pid, uint256 _amount) external override {\n        withdraw(_pid, _amount);\n        getReward(_pid);\n    }\n\n    function getReward(uint256 _pid) public override {\n        uint256 _amount = rewardEarned(_pid, msg.sender);\n        rewardToken.safeTransfer(msg.sender, _amount);\n    }\n\n    function rewardEarned(uint256 _pid, address _user) public view override returns (uint256) {\n        return poolBalance(_pid, _user).mul(rewardRate).div(1000);\n    }\n\n    function poolBalance(uint256 _pid, address _user) public view override returns (uint256) {\n        return userInfo[_pid][_user].amount;\n    }\n}\n"
    },
    "contracts/metavault/mock/MockYearnV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ncontract MockYearnV2 is ERC20 {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public underlying;\n\n    constructor(string memory name, string memory symbol, IERC20 _underlying) public ERC20(name, symbol) {\n        underlying = _underlying;\n    }\n\n    function balance() public view returns (uint256) {\n        return underlying.balanceOf(address(this));\n    }\n\n    function pricePerShare() public view returns (uint256) {\n        return balance().mul(1e18).div(totalSupply());\n    }\n\n    function deposit() external returns (uint256) {\n        uint256 _balance = underlying.balanceOf(msg.sender);\n        return deposit(_balance);\n    }\n\n    function deposit(uint256 _amount) public returns (uint256) {\n        uint256 underlyingTotal = balance();\n        uint256 _before = balance();\n        underlying.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 _after = balance();\n        _amount = _after.sub(_before);\n        uint256 shares;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(totalSupply())).div(underlyingTotal);\n        }\n        _mint(msg.sender, shares);\n        return shares;\n    }\n\n    function withdraw() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    function withdraw(uint256 _amount) public {\n        uint256 ret = (balance().mul(_amount)).div(totalSupply());\n        _burn(msg.sender, _amount);\n        underlying.safeTransfer(msg.sender, ret);\n    }\n\n    function token() external view returns (address) {\n        return address(underlying);\n    }\n}\n"
    },
    "contracts/metavault/mock/MockUniswapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ninterface IUniswapRouter {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n}\n\ncontract MockUniswapRouter is IUniswapRouter {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IERC20 univ2LpToken;\n\n    constructor(IERC20 _univ2LpToken) public {\n        univ2LpToken = _univ2LpToken;\n    }\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) public override returns (uint256[] memory amounts) {\n        return _swap(amountIn, amountOutMin, path, to, deadline);\n    }\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256[] memory amounts) {\n        return _swap(amountIn, amountOutMin, path, to, deadline);\n    }\n\n    function _swap(\n        uint256 amountIn,\n        uint256,\n        address[] calldata path,\n        address to,\n        uint256\n    ) internal returns (uint256[] memory amounts) {\n        uint256 amountOut = amountIn.mul(1); // assume 1 INPUT -> 1 OUTPUT\n        IERC20 inputToken = IERC20(path[0]);\n        IERC20 outputToken = IERC20(path[path.length - 1]);\n        inputToken.safeTransferFrom(msg.sender, address(this), amountIn);\n        outputToken.safeTransfer(to, amountOut);\n        amounts = new uint256[](2);\n        amounts[0] = amountIn;\n        amounts[1] = amountOut;\n    }\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint,\n        uint,\n        address to,\n        uint\n    ) external override returns (uint amountA, uint amountB, uint liquidity) {\n        amountA = (amountADesired < amountBDesired) ? amountADesired : amountBDesired;\n        amountB = amountA;\n        liquidity = amountA;\n        IERC20(tokenA).safeTransferFrom(msg.sender, address(this), amountA);\n        IERC20(tokenB).safeTransferFrom(msg.sender, address(this), amountB);\n        univ2LpToken.safeTransfer(to, liquidity); // 1A + 1B -> 1LP\n    }\n}\n"
    },
    "contracts/metavault/mock/MockIdleToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../interfaces/Idle.sol\";\n\ncontract MockIdleToken is ERC20, IIdleTokenV3_1 {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    address public override token;\n    IERC20 public rewardToken;\n    IERC20 public govToken;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _underlyingAsset,\n        address _rewardToken,\n        address _govToken\n    )\n        public\n        ERC20(_name, _symbol)\n    {\n        token = _underlyingAsset;\n        rewardToken = ERC20(_rewardToken);\n        govToken = ERC20(_govToken);\n    }\n\n    function mintIdleToken(uint256 _amount, bool, address) external override returns (uint256 mintedTokens) {\n        mintedTokens = _amount.mul(1e18).div(tokenPrice());\n        IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);\n        _mint(msg.sender, mintedTokens);\n    }\n\n    function redeemIdleToken(uint256 _amount) external override returns (uint256 redeemedTokens) {\n        uint256 price = tokenPrice();\n        redeemedTokens = _amount.mul(price).div(1e18);\n        _burn(msg.sender, _amount);\n        rewardToken.safeTransfer(msg.sender, 10e18);\n        govToken.safeTransfer(msg.sender, 5e18);\n        IERC20(token).safeTransfer(msg.sender, redeemedTokens);\n    }\n\n    function tokenPrice() public view override returns (uint256) {\n        return 2e18; // 1 idleDAI = 2 DAI\n    }\n}\n"
    },
    "contracts/interfaces/Idle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\ninterface IIdleTokenV3_1 {\n    function tokenPrice() external view returns (uint256 price);\n    function token() external view returns (address);\n    function mintIdleToken(uint256 _amount, bool _skipRebalance, address _referral) external returns (uint256 mintedTokens);\n    function redeemIdleToken(uint256 _amount) external returns (uint256 redeemedTokens);\n}\n"
    },
    "contracts/metavault/strategies/StrategyIdle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../../interfaces/Idle.sol\";\nimport \"../IConverter.sol\";\nimport \"./BaseStrategy.sol\";\n\ncontract StrategyIdle is BaseStrategy {\n    address public immutable idleYieldToken;\n    address public immutable IDLE;\n    address public immutable COMP;\n    IConverter public converter;\n\n    constructor(\n        string memory _name,\n        address _underlying,\n        address _idleYieldToken,\n        address _IDLE,\n        address _COMP,\n        address _converter,\n        address _controller,\n        address _vaultManager,\n        address _weth,\n        address _router\n    )\n        public\n        BaseStrategy(_name, _controller, _vaultManager, _underlying, _weth, _router)\n    {\n        require(_idleYieldToken != address(0), \"!_idleYieldToken\");\n        require(_IDLE != address(0), \"!_IDLE\");\n        require(_COMP != address(0), \"!_COMP\");\n        require(_converter != address(0), \"!_converter\");\n        idleYieldToken = _idleYieldToken;\n        IDLE = _IDLE;\n        COMP = _COMP;\n        converter = IConverter(_converter);\n        IERC20(_IDLE).safeApprove(address(_router), type(uint256).max);\n        IERC20(_COMP).safeApprove(address(_router), type(uint256).max);\n        IERC20(_underlying).safeApprove(address(_converter), type(uint256).max);\n        IERC20(_underlying).safeApprove(_idleYieldToken, type(uint256).max);\n    }\n\n    function balanceOfPool() public view override returns (uint256) {\n        uint256 balance = balanceOfYieldToken();\n        return balance\n            .mul(pricePerToken())\n            .div(1e18);\n    }\n\n    function pricePerToken() public view returns (uint256) {\n        return IIdleTokenV3_1(idleYieldToken).tokenPrice();\n    }\n\n    function balanceOfYieldToken() public view returns (uint256) {\n        return IERC20(idleYieldToken).balanceOf(address(this));\n    }\n\n    function _deposit() internal override {\n        uint256 balance = balanceOfWant();\n        if (balance > 0) {\n            IIdleTokenV3_1(idleYieldToken).mintIdleToken(balance, true, address(0));\n        }\n    }\n\n    function _harvest() internal override {\n        IIdleTokenV3_1(idleYieldToken).redeemIdleToken(0);\n        uint256 remainingWeth = _payHarvestFees(IDLE);\n\n        _liquidateAsset(COMP, want);\n\n        if (remainingWeth > 0) {\n            _swapTokens(weth, want, remainingWeth);\n        }\n\n        _deposit();\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        _amount = _amount.mul(1e18).div(IIdleTokenV3_1(idleYieldToken).tokenPrice());\n        IIdleTokenV3_1(idleYieldToken).redeemIdleToken(_amount);\n\n        _liquidateAsset(COMP, want);\n        _liquidateAsset(IDLE, want);\n\n        _amount = balanceOfWant();\n        if (_amount > 0) {\n            _convert(want, _vaultWant(), _amount);\n        }\n    }\n\n    function _withdrawAll() internal override {\n        uint256 balance = balanceOfYieldToken();\n        IIdleTokenV3_1(idleYieldToken).redeemIdleToken(balance);\n\n        _liquidateAsset(COMP, want);\n        _liquidateAsset(IDLE, want);\n\n        balance = balanceOfWant();\n        if (balance > 0) {\n            _convert(want, _vaultWant(), balance);\n        }\n    }\n\n    function _convert(address _from, address _to, uint256 _amount) internal {\n        require(converter.convert_rate(_from, _to, _amount) > 0, \"!convert_rate\");\n        IERC20(_from).safeTransfer(address(converter), _amount);\n        converter.convert(_from, _to, _amount);\n    }\n\n    function _liquidateAsset(address asset, address to) internal {\n        uint256 assetBalance = IERC20(asset).balanceOf(address(this));\n        if (assetBalance > 0) {\n            _swapTokens(asset, to, assetBalance);\n        }\n    }\n}\n"
    },
    "contracts/metavault/mock/MockFlamIncome.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./MockERC20.sol\";\n\ncontract MockFlamIncomeVault is MockERC20 {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    IERC20 public token;\n\n    uint public min = 9500;\n    uint public constant max = 10000;\n\n    constructor (address _token) public MockERC20(\n        string(abi.encodePacked(\"flamincomed \", ERC20(_token).name())),\n        string(abi.encodePacked(\"f\", ERC20(_token).symbol())),\n        ERC20(_token).decimals()\n    ) {\n        token = IERC20(_token);\n    }\n\n    function balance() public view returns (uint) {\n        return token.balanceOf(address(this));\n    }\n\n    function available() public view returns (uint) {\n        return token.balanceOf(address(this)).mul(min).div(max);\n    }\n\n    function depositAll() external {\n        deposit(token.balanceOf(msg.sender));\n    }\n\n    function deposit(uint _amount) public {\n        uint _pool = balance();\n        uint _before = token.balanceOf(address(this));\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint _after = token.balanceOf(address(this));\n        _amount = _after.sub(_before);\n        uint shares = 0;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        _mint(msg.sender, shares);\n    }\n\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    function withdraw(uint _shares) public {\n        uint r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n        token.safeTransfer(msg.sender, r);\n    }\n\n    function priceE18() public view returns (uint) {\n        return balance().mul(1e18).div(totalSupply());\n    }\n}\n"
    },
    "contracts/metavault/mock/MockDRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ncontract MockDRewards {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public lpToken;\n    IERC20 public rewardToken;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    uint256 rewardRate; // over 1000\n\n    constructor(\n        address _lpToken,\n        address _rewardToken,\n        uint256 _rewardRate\n    ) public {\n        lpToken = IERC20(_lpToken);\n        rewardToken = IERC20(_rewardToken);\n        rewardRate = _rewardRate;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return balanceOf(account).mul(rewardRate).div(1000);\n    }\n\n    function stake(uint256 amount) public {\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        lpToken.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(uint256 amount) public {\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        lpToken.safeTransfer(msg.sender, amount);\n    }\n\n    function exit() external {\n        withdraw(balanceOf(msg.sender));\n        getReward();\n    }\n\n    function getReward() public {\n        uint256 reward = earned(msg.sender);\n        if (reward > 0) {\n            if (reward > rewardToken.balanceOf(address(this))) {\n                reward = rewardToken.balanceOf(address(this));\n            }\n            rewardToken.safeTransfer(msg.sender, reward);\n        }\n    }\n}\n"
    },
    "contracts/metavault/mock/MockDErc20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ncontract MockDErc20 is ERC20 {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public underlying;\n\n    constructor(string memory name, string memory symbol, IERC20 _underlying) public ERC20(name, symbol) {\n        underlying = _underlying;\n    }\n\n    function getExchangeRate() public pure returns (uint256) {\n        return 2e18; // 1 dDAI = 2 DAI\n    }\n\n    function getTokenBalance(address _account) external view returns (uint256) {\n        return balanceOf(_account).mul(getExchangeRate()).div(1e18);\n    }\n\n    function mint(address _account, uint256 _amount) external {\n        uint256 _toMint = _amount.mul(1e18).div(getExchangeRate());\n        underlying.safeTransferFrom(msg.sender, address(this), _amount);\n        _mint(_account, _toMint);\n    }\n\n    function redeem(address _account, uint256 _amount) external {\n        uint256 _underlyingAmount = _amount.mul(getExchangeRate()).div(1e18);\n        _burn(_account, _amount);\n        underlying.safeTransfer(msg.sender, _underlyingAmount);\n    }\n}\n"
    },
    "contracts/metavault/mock/MockCurveMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../../interfaces/Gauge.sol\";\n\ncontract MockCurveMinter is Mintr {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IERC20 crv;\n\n    constructor(IERC20 _crv) public {\n        crv = _crv;\n    }\n\n    function mint(address) external override {\n        uint _bal = crv.balanceOf(address(this));\n        crv.safeTransfer(msg.sender, _bal.div(10)); // always mint 10% amount of balance\n    }\n}\n"
    },
    "contracts/interfaces/Gauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\ninterface Gauge {\n    function deposit(uint) external;\n    function balanceOf(address) external view returns (uint);\n    function withdraw(uint) external;\n    function claimable_tokens(address) external view returns (uint);\n}\n\ninterface Mintr {\n    function mint(address) external;\n}\n"
    },
    "contracts/metavault/strategies/StrategyCurve3Crv.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../../interfaces/Gauge.sol\";\nimport \"../../interfaces/Balancer.sol\";\n\nimport \"./BaseStrategy.sol\";\n\ncontract StrategyCurve3Crv is BaseStrategy {\n    // used for Crv -> weth -> [dai/usdc/usdt] -> 3crv route\n    address public immutable crv;\n\n    // for add_liquidity via curve.fi to get back 3CRV (use getMostPremium() for the best stable coin used in the route)\n    address public immutable dai;\n    address public immutable usdc;\n    address public immutable usdt;\n\n    Mintr public immutable crvMintr;\n    IStableSwap3Pool public immutable stableSwap3Pool;\n    Gauge public immutable gauge; // 3Crv Gauge\n\n    constructor(\n        string memory _name,\n        address _want,\n        address _crv,\n        address _weth,\n        address _dai,\n        address _usdc,\n        address _usdt,\n        Gauge _gauge,\n        Mintr _crvMintr,\n        IStableSwap3Pool _stableSwap3Pool,\n        address _controller,\n        address _vaultManager,\n        address _router\n    )\n        public\n        BaseStrategy(_name, _controller, _vaultManager, _want, _weth, _router)\n    {\n        require(_crv != address(0), \"!_crv\");\n        require(_dai != address(0), \"!_dai\");\n        require(_usdc != address(0), \"!_usdc\");\n        require(_usdt != address(0), \"!_usdt\");\n        require(address(_gauge) != address(0), \"!_gauge\");\n        require(address(_crvMintr) != address(0), \"!_crvMintr\");\n        require(address(_stableSwap3Pool) != address(0), \"!_stableSwap3Pool\");\n        crv = _crv;\n        dai = _dai;\n        usdc = _usdc;\n        usdt = _usdt;\n        stableSwap3Pool = _stableSwap3Pool;\n        gauge = _gauge;\n        crvMintr = _crvMintr;\n        IERC20(_want).safeApprove(address(_gauge), type(uint256).max);\n        IERC20(_crv).safeApprove(address(_router), type(uint256).max);\n        IERC20(_dai).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_usdc).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_usdt).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_want).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n    }\n\n    function _deposit() internal override {\n        uint256 _wantBal = balanceOfWant();\n        if (_wantBal > 0) {\n            // deposit [want] to Gauge\n            gauge.deposit(_wantBal);\n        }\n    }\n\n    function _claimReward() internal {\n        crvMintr.mint(address(gauge));\n    }\n\n    function _addLiquidity() internal {\n        uint256[3] memory amounts;\n        amounts[0] = IERC20(dai).balanceOf(address(this));\n        amounts[1] = IERC20(usdc).balanceOf(address(this));\n        amounts[2] = IERC20(usdt).balanceOf(address(this));\n        stableSwap3Pool.add_liquidity(amounts, 1);\n    }\n\n    function getMostPremium() public view returns (address, uint256) {\n        uint256[] memory balances = new uint256[](3);\n        balances[0] = stableSwap3Pool.balances(0); // DAI\n        balances[1] = stableSwap3Pool.balances(1).mul(10**12); // USDC\n        balances[2] = stableSwap3Pool.balances(2).mul(10**12); // USDT\n\n        if (balances[0] < balances[1] && balances[0] < balances[2]) { // DAI\n            return (dai, 0);\n        }\n\n        if (balances[1] < balances[0] && balances[1] < balances[2]) { // USDC\n            return (usdc, 1);\n        }\n\n        if (balances[2] < balances[0] && balances[2] < balances[1]) { // USDT\n            return (usdt, 2);\n        }\n\n        return (dai, 0); // If they're somehow equal, we just want DAI\n    }\n\n    function _harvest() internal override {\n        _claimReward();\n        uint256 _remainingWeth = _payHarvestFees(crv);\n\n        if (_remainingWeth > 0) {\n            (address _stableCoin,) = getMostPremium(); // stablecoin we want to convert to\n            _swapTokens(weth, _stableCoin, _remainingWeth);\n            _addLiquidity();\n\n            if (balanceOfWant() > 0) {\n                _deposit();\n            }\n        }\n    }\n\n    function _withdrawAll() internal override {\n        uint256 _bal = gauge.balanceOf(address(this));\n        _withdraw(_bal);\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        gauge.withdraw(_amount);\n    }\n\n    function balanceOfPool() public view override returns (uint) {\n        return gauge.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/interfaces/Balancer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\ninterface Balancer {\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn) external;\n    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut) external;\n    function swapExactAmountIn(\n        address tokenIn,\n        uint tokenAmountIn,\n        address tokenOut,\n        uint minAmountOut,\n        uint maxPrice\n    ) external returns (uint tokenAmountOut, uint spotPriceAfter);\n    function swapExactAmountOut(\n        address tokenIn,\n        uint maxAmountIn,\n        address tokenOut,\n        uint tokenAmountOut,\n        uint maxPrice\n    ) external returns (uint tokenAmountIn, uint spotPriceAfter);\n    function joinswapExternAmountIn(\n        address tokenIn,\n        uint tokenAmountIn,\n        uint minPoolAmountOut\n    ) external returns (uint poolAmountOut);\n    function exitswapPoolAmountIn(\n        address tokenOut,\n        uint poolAmountIn,\n        uint minAmountOut\n    ) external returns (uint tokenAmountOut);\n}\n"
    },
    "contracts/metavault/mock/MockCurveGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../../interfaces/Gauge.sol\";\n\ncontract MockCurveGauge is Gauge {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IERC20 want;\n\n    mapping(address => uint) public amounts;\n\n    constructor(IERC20 _want) public {\n        want = _want;\n    }\n\n    function deposit(uint _amount) external override {\n        want.safeTransferFrom(msg.sender, address(this), _amount);\n        amounts[msg.sender] = amounts[msg.sender].add(_amount);\n    }\n\n    function balanceOf(address _account) external override view returns (uint) {\n        return amounts[_account];\n    }\n\n    function claimable_tokens(address _account) external override view returns (uint) {\n        return amounts[_account].div(10); // always return 10% of staked\n    }\n\n    function withdraw(uint _amount) external override {\n        want.safeTransfer(msg.sender, _amount);\n        amounts[msg.sender] = amounts[msg.sender].sub(_amount);\n    }\n}\n"
    },
    "contracts/legacy/mock/MockYaxisBar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ncontract MockYaxisBar is ERC20 {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable YAX;\n\n    constructor(\n        address _yax\n    )\n        public\n        ERC20(\"Staked yAxis\", \"sYAX\")\n    {\n        YAX = IERC20(_yax);\n    }\n\n    function availableBalance()\n        external\n        view\n        returns (uint256)\n    {\n        return YAX.balanceOf(address(this));\n    }\n\n    function enter(\n        uint256 _amount\n    )\n        external\n    {\n        require(_amount > 0, \"!_amount\");\n        _mint(msg.sender, _amount.mul(1e18).div(getPricePerFullShare()));\n        YAX.safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    function leave(\n        uint256 _amount\n    )\n        public\n    {\n        require(_amount > 0, \"!_amount\");\n        _burn(msg.sender, _amount);\n        YAX.safeTransfer(msg.sender, _amount.mul(getPricePerFullShare()).div(1e18));\n    }\n\n    function exit()\n        external\n    {\n        leave(balanceOf(msg.sender));\n    }\n\n    function getPricePerFullShare()\n        public\n        view\n        returns (uint256)\n    {\n        return totalSupply() == 0\n            ? 1e18\n            : YAX.balanceOf(address(this)).mul(1e18).div(totalSupply());\n    }\n}\n"
    },
    "contracts/legacy/mock/MockUniswapPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ncontract MockUniswapPair is ERC20 {\n    using SafeERC20 for IERC20;\n\n    address public immutable token0;\n    address public immutable token1;\n\n    constructor(\n        address _token0,\n        address _token1\n    )\n        public\n        ERC20(\"Uniswap Pair\", \"UNI-V2\")\n    {\n        token0 = _token0;\n        token1 = _token1;\n    }\n\n    function addLiquidity(\n        uint256 _amount0,\n        uint256 _amount1,\n        uint256 _amountOut\n    )\n        external\n    {\n        IERC20(token0).safeTransferFrom(msg.sender, address(this), _amount0);\n        IERC20(token1).safeTransferFrom(msg.sender, address(this), _amount1);\n        _mint(msg.sender, _amountOut);\n    }\n\n    function getReserves()\n        external\n        view\n        returns (uint112, uint112, uint32)\n    {\n        return (\n            uint112(IERC20(token0).balanceOf(address(this))),\n            uint112(IERC20(token1).balanceOf(address(this))),\n            uint32(block.timestamp)\n        );\n    }\n}\n"
    },
    "contracts/metavault/strategies/StrategyFlamIncome.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"../../interfaces/FlamIncome.sol\";\nimport \"./StrategyGenericVault.sol\";\n\ncontract StrategyFlamIncome is StrategyGenericVault {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @param _vault The address of the vault\n     * @param _converter The address of the converter\n     * @param _controller The address of the controller\n     * @param _vaultManager The address of the vaultManager\n     * @param _weth The address of WETH\n     * @param _router The address of the router for swapping tokens\n     */\n    constructor(\n        address _vault,\n        address _converter,\n        address _controller,\n        address _vaultManager,\n        address _weth,\n        address _router\n    )\n        public\n        StrategyGenericVault(\n            string(abi.encodePacked(\"FlamIncome: \", ERC20(IVault(_vault).token()).symbol())),\n            _vault,\n            _converter,\n            _controller,\n            _vaultManager,\n            _weth,\n            _router\n        )\n    {}\n\n    function getPricePerFullShare() public view override returns(uint256) {\n        return priceE18();\n    }\n\n    function priceE18() public view returns (uint256) {\n        return IVault(vault).priceE18();\n    }\n}\n"
    },
    "contracts/interfaces/FlamIncome.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\ninterface IVault {\n    function token() external view returns (address);\n    function priceE18() external view returns (uint);\n    function deposit(uint) external;\n    function withdraw(uint) external;\n    function depositAll() external;\n    function withdrawAll() external;\n}\n"
    },
    "contracts/metavault/strategies/StrategyDforce.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../../interfaces/DForce.sol\";\nimport \"../IConverter.sol\";\nimport \"./BaseStrategy.sol\";\n\ncontract StrategyDforce is BaseStrategy {\n    address public immutable dToken;\n    address public immutable pool;\n    address public immutable DF;\n    IConverter public converter;\n\n    constructor(\n        string memory _name,\n        address _underlying,\n        address _dToken,\n        address _pool,\n        address _DF,\n        address _converter,\n        address _controller,\n        address _vaultManager,\n        address _weth,\n        address _router\n    )\n        public\n        BaseStrategy(_name, _controller, _vaultManager, _underlying, _weth, _router)\n    {\n        require(_dToken != address(0), \"!_dToken\");\n        require(_pool != address(0), \"!_pool\");\n        require(_DF != address(0), \"!_DF\");\n        require(_converter != address(0), \"!_converter\");\n        dToken = _dToken;\n        pool = _pool;\n        DF = _DF;\n        converter = IConverter(_converter);\n        IERC20(_DF).safeApprove(address(_router), type(uint256).max);\n        IERC20(_underlying).safeApprove(address(_converter), type(uint256).max);\n        IERC20(_underlying).safeApprove(_dToken, type(uint256).max);\n        IERC20(_dToken).safeApprove(_pool, type(uint256).max);\n    }\n\n    function balanceOfPool() public view override returns (uint256) {\n        return (dRewards(pool).balanceOf(address(this)))\n            .mul(dERC20(dToken).getExchangeRate())\n            .div(1e18)\n            .add(balanceOfdToken());\n    }\n\n    function balanceOfdToken() public view returns (uint256) {\n        return dERC20(dToken).getTokenBalance(address(this));\n    }\n\n    function _deposit() internal override {\n        uint256 _amount = balanceOfWant();\n        if (_amount > 0) {\n            dERC20(dToken).mint(address(this), _amount);\n        }\n        uint256 _dToken = IERC20(dToken).balanceOf(address(this));\n        if (_dToken > 0) {\n            dRewards(pool).stake(_dToken);\n        }\n    }\n\n    function _harvest() internal override {\n        dRewards(pool).getReward();\n        uint256 _remainingWeth = _payHarvestFees(DF);\n\n        if (_remainingWeth > 0) {\n            _swapTokens(weth, want, _remainingWeth);\n\n            if (balanceOfWant() > 0) {\n                _deposit();\n            }\n        }\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        _amount = _amount.mul(1e18).div(dERC20(dToken).getExchangeRate());\n        uint256 _before = IERC20(dToken).balanceOf(address(this));\n        dRewards(pool).withdraw(_amount);\n        uint256 _after = IERC20(dToken).balanceOf(address(this));\n        _amount = _after.sub(_before);\n        dERC20(dToken).redeem(address(this), _amount);\n        _amount = balanceOfWant();\n        if (_amount > 0) {\n            _convert(want, _vaultWant(), _amount);\n        }\n    }\n\n    function _withdrawAll() internal override {\n        dRewards(pool).exit();\n        uint256 _amount = IERC20(dToken).balanceOf(address(this));\n        if (_amount > 0) {\n            dERC20(dToken).redeem(address(this), _amount);\n            _amount = balanceOfWant();\n            _convert(want, _vaultWant(), _amount);\n        }\n    }\n\n    function _convert(address _from, address _to, uint256 _amount) internal {\n        require(converter.convert_rate(_from, _to, _amount) > 0, \"!convert_rate\");\n        IERC20(_from).safeTransfer(address(converter), _amount);\n        converter.convert(_from, _to, _amount);\n    }\n}\n"
    },
    "contracts/interfaces/DForce.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\ninterface dRewards {\n    function withdraw(uint) external;\n    function getReward() external;\n    function stake(uint) external;\n    function balanceOf(address) external view returns (uint);\n    function exit() external;\n}\n\ninterface dERC20 {\n  function mint(address, uint256) external;\n  function redeem(address, uint) external;\n  function getTokenBalance(address) external view returns (uint);\n  function getExchangeRate() external view returns (uint);\n}\n"
    },
    "contracts/metavault/mock/MockPickleMasterChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MockPickleMasterChef {\n    IERC20 public pickleToken;\n    IERC20 public lpToken;\n\n    struct UserInfo {\n        uint amount; // How many LP tokens the user has provided.\n        uint rewardDebt; // Reward debt. See explanation below.\n    }\n\n    mapping(uint => mapping(address => UserInfo)) public userInfo;\n\n    constructor(IERC20 _pickleToken, IERC20 _lpToken) public {\n        pickleToken = _pickleToken;\n        lpToken = _lpToken;\n    }\n\n    function deposit(uint _pid, uint _amount) external {\n        lpToken.transferFrom(msg.sender, address(this), _amount);\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        pickleToken.transfer(msg.sender, user.amount / 10); // always get 10% of deposited amount\n        user.amount = user.amount + _amount;\n    }\n\n    function withdraw(uint _pid, uint _amount) external {\n        lpToken.transfer(msg.sender, _amount);\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        pickleToken.transfer(msg.sender, user.amount / 10); // always get 10% of deposited amount\n        user.amount = user.amount - _amount;\n    }\n\n    function pendingPickle(uint, address) external view returns (uint) {\n        return pickleToken.balanceOf(address(this)) / 10;\n    }\n\n    function emergencyWithdraw(uint _pid) external {\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        lpToken.transfer(msg.sender, user.amount);\n        user.amount = 0;\n        user.rewardDebt = 0;\n    }\n}\n"
    },
    "contracts/governance/YaxisVoteProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IVoteProxy.sol\";\n\ncontract YaxisVoteProxy {\n    IVoteProxy public voteProxy;\n    address public governance;\n    constructor() public {\n        governance = msg.sender;\n    }\n\n    function name() external pure returns (string memory) {\n        return \"YAXIS Vote Power\";\n    }\n\n    function symbol() external pure returns (string memory) {\n        return \"YAX VP\";\n    }\n\n    function decimals() external view returns (uint8) {\n        return voteProxy.decimals();\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return voteProxy.totalSupply();\n    }\n\n    function balanceOf(address _voter) external view returns (uint256) {\n        return voteProxy.balanceOf(_voter);\n    }\n\n    function setVoteProxy(IVoteProxy _voteProxy) external {\n        require(msg.sender == governance, \"!governance\");\n        voteProxy = _voteProxy;\n    }\n\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n\n\n/**\n * This function allows governance to take unsupported tokens out of the contract.\n * This is in an effort to make someone whole, should they seriously mess up.\n * There is no guarantee governance will vote to return these.\n * It also allows for removal of airdropped tokens.\n */\n    function governanceRecoverUnsupported(IERC20 _token, uint256 amount, address to) external {\n        require(msg.sender == governance, \"!governance\");\n        _token.transfer(to, amount);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}